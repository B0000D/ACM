[TOC]



# CCF-CSP  201312-4 有趣的数
标签: ccf
## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 1.0s | 256.0MB |

**题目描述**

　　我们把一个数称为有趣的，当且仅当：它的数字只包含0, 1, 2, 3，且这四个数字都出现过至少一次；所有的0都出现在所有的1之前，而所有的2都出现在所有的3之前；最高位数字不为0。
​	因此，符合我们定义的最小的有趣的数是2013。除此以外，4位的有趣的数还有两个：2031和2301。
​	请计算恰好有 $n$ 位的有趣的数的个数。由于答案可能非常大，只需要输出答案除以1000000007的余数。

**输入格式**

​	输入只有一行，包括恰好一个正整数 $n\ (4 ≤ n ≤ 1000)$。

**输出格式**

​	输出只有一行，包括恰好 $n$ 位的整数中有趣的数的个数除以1000000007的余数。

**样例输入**

```
4
```

**样例输出**

```
3
```

## 2、题解

**DP**

​	动态规划(Dynamic Programming，下文简称DP)是运筹学中用于求解决策过程中的最优化数学方法，而在算法设计中，DP是一种使用多阶段决策过程最优的通用方法。

1.  一般地，DP类型的题目都可以分解成更小的子问题，DP算法通常基于一个递推公式和若干初始状态，在解决子问题以后再通过状态转移得到现阶段待求问题的答案。
2.  由于问题中的状态都是有限可列的，DP算法比暴力法、回溯法更快。
3.  DP算法在表示状态时有更高的空间要求，是一种常见的以空间换时间的算法。 

**本题分析**

​	回到本题，题目大意即把0、1、2、3四个数字可重复地填入 $n$ 个位置，问得到的所有数字中有多少能满足“有趣的数”的定义。现在我们来模拟一下题目过程，我们从左往右依次向每一个位置填数，假设已经填满前 $i-1$ 位，当前考虑第 $i$ 位如何填放，那根据题目的几个填数规则，我们可以列举出当前所有可能的状态：
| 当前所有可能状态                                 |
| ---------------------------------------- |
| 前i-1位出现过一个数字，只能为"2"（最高位不能为"0"，1之前必有0则不能为"1"，3之前必有2则不能为"3"） |
| 前i-1位出现过两个数字，可能为"20"：                    |
| 前i-1位出现过两个数字，可能为"23"（1之前必有0则不能为"21"）     |
| 前i-1位出现过三个数字，可能为"201"                    |
| 前i-1位出现过三个数字，可能为"203"（1之前必有0则不能为"231"）   |
| 前i-1位出现过四个数字，只能为"2013"                   |
​	显然状态之间是有关联的，例如状态"203"，可以是"20"的基础上填放3，也可以是"23"的基础上填放0，若我们将以上的所有状态从0-5进行编号，即状态4可以由状态2和状态3转移得到。
​	想清楚模拟过程之后，解题的大致思路也已经出来了，只要我们能计算得到前 $i-1$ 位每个状态下“有趣的数”的个数，就可以通过状态转移得到填满第 $i$ 位后每个状态下“有趣的数”的个数。现在我们把这个实际问题抽象成数学模型，设 $f[i][j]$ 表示填满第 $i$ 位后，已用数字的状态编号为 $j$ 的所有“有趣的数”的个数，则 $f[i][j]$ 可以由 $f[i-1][k]$ ($0<=k<=5$, 实际取值根据填数规则由 $j$ 确定)转移得到，我们最终需要的答案就是 $f[n][5]$ (题目要求四个数字都出现过至少一次，只能为状态5)。

## 3、参考程序

```C++
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
typedef long long lint;
const int maxn=1000+10;
const lint mod=1000000007;

int n;
lint g[maxn][6], f[maxn][6];
/*
f[i][j]：填满第i位后，已用数字的状态编号为j(0~5)的所有“有趣的数”的个数
state 0: 用了2
state 1: 用了2、0
state 2: 用了2、3
state 3: 用了2、0、1
state 4：用了2、0、3
state 5: 用了2、0、1、3
*/

void Work()
{
	memcpy(f, g, sizeof g);	//初始化
	for(int i=5; i<=n; i++)
	{
		f[i][0]=f[i-1][0];
		//状态0的基础上放2
		f[i][1]=(f[i-1][0]+f[i-1][1]*2)%mod;
		//状态0的基础上放0，状态1的基础上放0或2
		f[i][2]=(f[i-1][0]+f[i-1][2])%mod;
		//状态0的基础上放3，状态2的基础上放3
		f[i][3]=(f[i-1][1]+f[i-1][3]*2)%mod;
		//状态1的基础上放1，状态3的基础上放1或2
		f[i][4]=(f[i-1][1]+f[i-1][2]+f[i-1][4]*2)%mod;
		//状态1的基础上放3，状态2的基础上放3，状态4的基础上放0或3
		f[i][5]=(f[i-1][3]+f[i-1][4]+f[i-1][5]*2)%mod;
		//状态3的基础上放3，状态4的基础上放1，状态5的基础上放1或3
	}
	printf("%lld\n", f[n][5]);
	return ;
}

int main()
{
	g[4][0]=1;	//2222
	g[4][1]=7;	//2220 2202 2022 2200 2020 2002 2000
	g[4][2]=3;	//2223 2233 2333
	g[4][3]=5;	//2001 2011 2201 2021 2012
	g[4][4]=9;	//2003 2030 2300 2023 2203 2230 2033 2303 2330
	g[4][5]=3;	//2013 2031 2301
	//初始化
	while(scanf("%d", &n)!=EOF)	Work();
	return 0;
}
```



# CCF-CSP  201312-5 I’m stuck!

## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 1.0s | 256.0MB |

**题目描述**

​	给定一个 $R$ 行 $C$ 列的地图，地图的每一个方格可能是'#', '+', '-', '|', '.', 'S', 'T'七个字符中的一个，分别表示如下意思：
　　'#': 任何时候玩家都不能移动到此方格；
　　'+': 当玩家到达这一方格后，下一步可以向上下左右四个方向相邻的任意一个非'#'方格移动一格；
　　'-': 当玩家到达这一方格后，下一步可以向左右两个方向相邻的一个非'#'方格移动一格；
　　'|': 当玩家到达这一方格后，下一步可以向上下两个方向相邻的一个非'#'方格移动一格；
　　'.': 当玩家到达这一方格后，下一步只能向下移动一格。如果下面相邻的方格为'#'，则玩家不能再移动；
　　'S': 玩家的初始位置，地图中只会有一个初始位置。玩家到达这一方格后，下一步可以向上下左右四个方向相邻的任意一个非'#'方格移动一格；
　　'T': 玩家的目标位置，地图中只会有一个目标位置。玩家到达这一方格后，可以选择完成任务，也可以选择不完成任务继续移动。如果继续移动下一步可以向上下左右四个方向相邻的任意一个非'#'方格移动一格。
　　此外，玩家不能移动出地图。
　　请找出满足下面两个性质的方格个数：玩家可以从初始位置移动到此方格；玩家不可以从此方格移动到目标位置。

**输入格式**

　　输入的第一行包括两个整数 $R$ 和 $C$，分别表示地图的行和列数。$(1 ≤ R, C ≤ 50)$。
　　接下来的 $R$ 行每行都包含 $C$ 个字符。它们表示地图的格子。地图上恰好有一个'S'和一个'T'。

**输出格式**

　　如果玩家在初始位置就已经不能到达终点了，就输出“I'm stuck!”（不含双引号）。否则的话，输出满足性质的方格的个数。

**样例输入**

```
5 5
--+-+
..|#.
..|##
S-+-T
####.
```

**样例输出**

```
2
```

**样例解释**

　　如果把满足性质的方格在地图上用'X'标记出来的话，地图如下所示：
　　--+-+
　　..|#X
　　..|##
　　S-+-T
　　\####X

## 2、题解

**DFS**

**本题分析**

　　这是一道典型的搜索题目。从'S'出发根据规则进行深度优先搜索（Depth First Search，以下简称DFS），则能得到满足性质一的所有点。那如何获得满足性质二的点呢？最直接的想法是将满足性质一的所有点作为起点再次进行DFS，以判断当前点能否到达'T'，但显然这样的做法耗时太大。我们换一种思路，若从某点A出发能够到达'T'，那我们将相应的规则取反之后，从'T'出发必定也能到达A点。因此，我们从'T'出发根据取反后的规则进行DFS，则能得到满足性质二的所有点。为了简化代码，我们可以把两次搜索合并到一个函数里，用一个变量标记当前搜索的起点是'S'还是'T'，并以此确定应该遵从原规则还是取反后的规则。

## 3、参考程序

```C++
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const int maxn=50+5;

int n, m, sx[2], sy[2], tx[2], ty[2];	//每次搜索的起点坐标放在s数组，终点坐标放在t数组
int dd[4][2]={0, -1, 0, 1, -1, 0, 1, 0};	//方向数组，搜索时由当前坐标向四个方向扩展
char s[maxn][maxn];	//读入地图
bool vis[2][maxn][maxn];	//搜索时用于标记当前坐标已被访问

bool Dfs(int p, int x, int y)	//第p(0代表从'S'出发，1代表从'T'出发)次搜索，当前坐标为(x,y)
{
	bool flag=(x==tx[p] && y==ty[p]);	//是否为终点
	vis[p][x][y]=true;	//标记当前坐标已被访问
	for(int i=0; i<4; i++)	//0、1、2、3分别表示向左、右、上、下四个方向扩展
	{
		int dx=x+dd[i][0], dy=y+dd[i][1];
		if(dx<1 || dx>n || dy<1 || dy>m || vis[p][dx][dy] || s[dx][dy]=='#')	continue;
		//以下三种情况时新坐标点不合法，进行下一次尝试
		//1. 新坐标超出坐标范围
		//2. 新坐标已被访问
		//3. 新坐标为障碍点
		//注意先判断新坐标是否在合法的坐标范围内，不然容易出现坐标越界问题
		if(p==0)
		{
			if(s[x][y]=='-' && i!=0 && i!=1)	continue;
			//方格'-'只能向左、右方向扩展
			if(s[x][y]=='|' && i!=2 && i!=3)	continue;
			//方格'|'只能向上、下方向扩展
			if(s[x][y]=='.' && i!=3)	continue;
			//方格'.'只能向下扩展
			flag|=Dfs(p, dx, dy);	//若向(dx,dy)方向扩展时可以到达终点，就表示从(x,y)出发能到达终点，那标记当前点的flag应该为真；否则异或运算不改变原flag值
		}
		else
		{
			if(s[dx][dy]=='-' && i!=0 && i!=1)	continue;
			if(s[dx][dy]=='|' && i!=2 && i!=3)	continue;
			if(s[dx][dy]=='.' && i!=2)	continue;
			//从终点向起点出发，因为方格'.'只能向下扩展，那相应的当前坐标应该向上扩展才能到达'.'
			flag|=Dfs(p, dx, dy);
		}
	}
	return flag;	//返回这条路是否可以到达终点
}

int main()
{
	while(scanf("%d%d", &n, &m)!=EOF)
	{
		for(int i=1; i<=n; i++)	scanf("%s", s[i]+1);
		for(int i=1; i<=n; i++)
			for(int j=1; j<=m; j++)
			{
				if(s[i][j]=='S')	sx[0]=i, sy[0]=j, tx[1]=i, ty[1]=j;
				else if(s[i][j]=='T')	tx[0]=i, ty[0]=j, sx[1]=i, sy[1]=j;
			}
		memset(vis, false, sizeof vis);
		if(!Dfs(0, sx[0], sy[0]))	printf("I'm stuck!\n");	//注意题目，若从起点已经不能到达终点，那直接输出"I'm stuck!"，不用进行反方向搜索
		else
		{
			Dfs(1, sx[1], sy[1]);	//从反方向进行搜索，标记能到达终点的点
			int ans=0;
			for(int i=1; i<=n; i++)
				for(int j=1; j<=m; j++)
					if(vis[0][i][j] && !vis[1][i][j])	ans++;	//计算能从起点到达、但从该点出发不能到达终点的点
			printf("%d\n", ans);
		}
	}
	return 0;
}
```



# CCF-CSP  201403-4 无线网络

## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 1.0s | 256.0MB |

**题目描述**

　　目前在一个很大的平面房间里有 $n$ 个无线路由器,每个无线路由器都固定在某个点上。任何两个无线路由器只要距离不超过 $r$ 就能互相建立网络连接。
　　除此以外,另有 $m$ 个可以摆放无线路由器的位置。你可以在这些位置中选择至多 $k$ 个增设新的路由器。
　　你的目标是使得第 1 个路由器和第 2 个路由器之间的网络连接经过尽量少的中转路由器。请问在最优方案下中转路由器的最少个数是多少?

**输入格式**

　　第一行包含四个正整数 $n,m,k,r$。$(2 ≤ n ≤ 100,1 ≤ k ≤ m ≤ 100, 1 ≤ r ≤ 10^8)$。
　　接下来 $n$ 行,每行包含两个整数 $x_i$ 和 $y_i$,表示一个已经放置好的无线 路由器在 $(x_i, y_i)$ 点处。输入数据保证第 1 和第 2 个路由器在仅有这 $n$ 个路由器的情况下已经可以互相连接(经过一系列的中转路由器)。
　　接下来 $m$ 行,每行包含两个整数 $x_i$ 和 $y_i$ ,表示 $(x_i, y_i)$ 点处可以增设一个路由器。
　　输入中所有的坐标的绝对值不超过 $10^8$,保证输入中的坐标各不相同。

**输出格式**

　　输出只有一个数,即在指定的位置中增设 $k$ 个路由器后,从第 1 个路由器到第 2 个路由器最少经过的中转路由器的个数。

**样例输入**

```
5 3 1 3
0 0
5 5
0 3
0 5
3 5
3 3
4 4
3 0
```

**样例输出**

```
2
```

## 2、题解

**SPFA**

　　SPFA算法是求单源最短路径的一种算法，它基于Bellman-ford的队列优化，能有效解决负环图问题，是一种十分高效的最短路算法，算法流程如下：
1. 建立一个数组用于保存从起点出发到达当前点的最短路径，不妨记为 $dis[]$ ，对于起点 $S$ ，$dis[S]$初始赋为0，对于图中其余任意一点 $A$，$dis[A]$ 初始赋为极大值。
2. 建立一个队列，队内初始只有起点 $S$。
3. 首先取出队首点，不妨记其为 $u$，然后执行松弛操作，即对于 $u$ 的任意一个邻接点 $v$，若 $dis[u]$ 加上 $<u, v>$ 的边权小于 $dis[v]$，则更新 $dis[v]$ 的值，更新的同时判断 $v$ 是否在队列中，若不在，将 $v$ 加入队列。
4. 重复取点、松弛的操作，直至队列为空。
5. 另外，若某个点入队次数大于总点数 $n$，则说明图中存在负环图。本文着重讲解解题思路，算法有关的原理及证明请同学自行搜集有关资料学习。

**本题分析**

　　在本题中，由于增加了中转路由器这样一个属性，我们可以在 $dis[]$ 的基础上再增加一维，用来表示当前最短路经过的中转路由器的个数，在执行松弛操作时根据邻接点 $v$ 是否为中转路由器来进行不同的最短路径值的更新。我们最终需要的答案就是 $dis[T][k]$ (到达终点 $T$ 且经过 $k$ 个中转路由器的最短路径)。

## 3、参考程序

```C++
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<queue>
#include<algorithm>
using namespace std;
const int maxn=200+10, maxm=40000+10, S=1, T=2;	//已经确定起点和终点的序号分别为1、2

int n, m, k, dis[maxn][maxn];	//dis[i][j]：从起点到达i，额外选中j个点所经过的最短点数
int cur, fir[maxn], ver[maxm<<1], nxt[maxm<<1];
double r;
bool vis[maxn];
struct node
{
	double x, y;
	void read()
	{
		scanf("%lf%lf", &x, &y);
		return ;
	}
}p[maxn<<1];

void Add(int u, int v)
{
	ver[++cur]=v, nxt[cur]=fir[u], fir[u]=cur;
	ver[++cur]=u, nxt[cur]=fir[v], fir[v]=cur;
	return ;
}

double Dis(node a, node b)
{
	double x=a.x-b.x, y=a.y-b.y;
	return sqrt(x*x+y*y);
}

void Work()
{
	memset(dis, -1, sizeof dis);
	memset(vis, false, sizeof vis);

	queue<int> q;
	q.push(S);
	dis[S][0]=0, vis[S]=true;

	while(!q.empty())
	{
		int u=q.front();

		for(int h=0; h<=k; h++) if(dis[u][h]!=-1)	//dis[u][h]表示从u点出发，已经额外增设了h个点的方案是可行的，由此向它相邻的点进行扩展
			for(int i=fir[u], v; i; i=nxt[i])
			{
				v=ver[i];
				if(v>n && h<k && (dis[v][h+1]==-1 || dis[v][h+1]>=dis[u][h]+1))
				{
					//v点为额外点，且额外点的数目仍然在范围内
					dis[v][h+1]=dis[u][h]+1;
					if(!vis[v])
					{
						q.push(v);
						vis[v]=true;
					}
				}
				else if(dis[v][h]==-1 || dis[v][h]>=dis[u][h]+1)
				{
					dis[v][h]=dis[u][h]+1;
					if(!vis[v])
					{
						q.push(v);
						vis[v]=true;
					}
				}
			}
		
		q.pop();
	}

	int ans=-1;
	for(int i=0; i<=k; i++) if(dis[T][i]!=-1)	ans=(ans==-1 ? dis[T][i] : min(ans, dis[T][i]));	//求能到达T点的所有方案的最小距离
	printf("%d\n", ans-1);
	return ;
}

int main()
{
	while(scanf("%d%d%d%lf", &n, &m, &k, &r)!=EOF)
	{
		cur=0;
		memset(fir, 0, sizeof fir);

		for(int i=1; i<=n+m; i++)	p[i].read();	//读入，1~n为原有路由器坐标，n+1~m为可以增设的路由器坐标
		for(int i=1; i<=n+m; i++)
			for(int j=i+1; j<=n+m; j++)
				if(Dis(p[i], p[j])<=r)	Add(i, j);	//满足条件的所有点互相连边
		
		Work();
	}
	return 0;
}
```



# CCF-CSP  201403-5 任务调度

## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 1.0s | 256.0MB |

**题目描述**

　　有若干个任务需要在一台机器上运行。它们之间没有依赖关系,因此 可以被按照任意顺序执行。
　　该机器有两个 CPU 和一个 GPU。对于每个任务,你可以为它分配不 同的硬件资源:
​	1. 在单个 CPU 上运行。
​	2. 在两个 CPU 上同时运行。
​	3. 在单个 CPU 和 GPU 上同时运行。
​	4. 在两个 CPU 和 GPU 上同时运行。
　　一个任务开始执行以后,将会独占它所用到的所有硬件资源,不得中 断,直到执行结束为止。第 $i$ 个任务用单个 CPU,两个 CPU,单个 CPU 加 GPU,两个 CPU 加 GPU 运行所消耗的时间分别为 $a_i,b_i,c_i$ 和 $d_i$。
　　现在需要你计算出至少需要花多少时间可以把所有给定的任务完成。

**输入格式**

　　输入的第一行只有一个正整数 $n\ (1 ≤ n ≤ 40)$, 是总共需要执行的任务个数。
　　接下来的 $n$ 行每行有四个正整数 $a_i, b_i, c_i, d_i$ ($a_i, b_i, c_i, d_i$ 均不超过 10), 以空格隔开。

**输出格式**

　　输出只有一个整数,即完成给定的所有任务所需的最少时间。

**样例输入**

```
3
4 4 2 2
7 4 7 4
3 3 3 3
```

**样例输出**

```
7
```

**样例说明**

　　有很多种调度方案可以在 7 个时间单位里完成给定的三个任务,以下是其中的一种方案:
　　同时运行第一个任务(单 CPU 加上 GPU)和第三个任务(单 CPU), 它们分别在时刻 2 和时刻 3 完成。在时刻 3 开始双 CPU 运行任务 2,在 时刻 7 完成。

## 2、题解

## 3、参考程序

```

```



# CCF-CSP  201409-4 最优配餐

## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 1.0s | 256.0MB |

**题目描述**

　　栋栋最近开了一家餐饮连锁店，提供外卖服务。随着连锁店越来越多，怎么合理的给客户送餐成为了一个急需解决的问题。
　　栋栋的连锁店所在的区域可以看成是一个 $n×n$ 的方格图（如下图所示），方格的格点上的位置上可能包含栋栋的分店（绿色标注）或者客户（蓝色标注），有一些格点是不能经过的（红色标注）。
![](201409-4.png)
　　方格图中的线表示可以行走的道路，相邻两个格点的距离为1。栋栋要送餐必须走可以行走的道路，而且不能经过红色标注的点。
　　送餐的主要成本体现在路上所花的时间，每一份餐每走一个单位的距离需要花费1块钱。每个客户的需求都可以由栋栋的任意分店配送，每个分店没有配送总量的限制。
　　现在你得到了栋栋的客户的需求，请问在最优的送餐方式下，送这些餐需要花费多大的成本。

**输入格式**

　　输入的第一行包含四个整数 $n, m, k, d$，分别表示方格图的大小、栋栋的分店数量、客户的数量，以及不能经过的点的数量。
　　接下来 $m$ 行，每行两个整数 $x_i, y_i$ ，表示栋栋的一个分店在方格图中的横坐标和纵坐标。
　　接下来 $k$ 行，每行三个整数 $x_i, y_i, c_i$，分别表示每个客户在方格图中的横坐标、纵坐标和订餐的量。（注意，可能有多个客户在方格图中的同一个位置）
　　接下来 $d$ 行，每行两个整数，分别表示每个不能经过的点的横坐标和纵坐标。

**输出格式**

　　输出一个整数，表示最优送餐方式下所需要花费的成本。

**样例输入**

```
10 2 3 3
1 1
8 8
1 5 1
2 3 3
6 7 2
1 2
2 2
6 8
```

**样例输出**

```
29
```

**评测用例规模与约定**

　　前30%的评测用例满足：$1≤ n ≤20$。
　　前60%的评测用例满足：$1≤n≤100$。
　　所有评测用例都满足：$1≤n≤1000，1≤m, k, d≤n^2$。可能有多个客户在同一个格点上。每个客户的订餐量不超过1000，每个客户所需要的餐都能被送到。

## 2、题解

**BFS**

**本题分析**

　　将所有的分店作为起点，进行宽度优先搜索（Breadth First Search，简称BFS），直到找到所有客户。

## 3、参考程序

```C++
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<queue>
#include<algorithm>
using namespace std;
const int maxn=1000+10, maxm=1000000+10;
typedef long long lint;	//避免最终答案超过int范围，使用long long类型，此处将lint定义为long long类型别名

int n, m, k, d, cnt[maxn][maxn], tot[maxn][maxn], mmp[maxn][maxn], dis[maxn][maxn];
int dd[4][2]={0, 1, 0, -1, 1, 0, -1, 0};
bool vis[maxn][maxn];
struct node
{
	int x, y, c;
	node(int _x=0, int _y=0, int _c=0)	//构造函数
	{
		x=_x, y=_y, c=_c;
	}
};
queue<node> q;

lint Bfs()
{
	lint ans=0;	//记录总费用ans
	int sum=0;	//记录已经送达的客户树木

	while(!q.empty() && sum<k)
	{
		node t=q.front();
		q.pop();

		if(mmp[t.x][t.y]==1)	//若当前点为客户节点，更新sum和ans
		{
			sum+=cnt[t.x][t.y];
			ans+=(lint)tot[t.x][t.y]*t.c;
		}

		for(int i=0; i<4; i++)
		{
			int px=t.x+dd[i][0], py=t.y+dd[i][1];
			if(px<1 || px>n || py<1 || py>n || mmp[px][py]==-1 || vis[px][py])	continue;

			vis[px][py]=true;
			q.push(node(px, py, t.c+1));
		}
	}

	return ans;
}

int main()
{
	while(scanf("%d%d%d%d", &n, &m, &k, &d)!=EOF)
	{
		memset(cnt, 0, sizeof cnt);
		memset(tot, 0, sizeof tot);
		memset(mmp, 0, sizeof mmp);
		memset(dis, 0, sizeof dis);
		memset(vis, false, sizeof vis);
		while(!q.empty())	q.pop();

		for(int i=1, x, y; i<=m; i++)
		{
			scanf("%d%d", &x, &y);
			vis[x][y]=true;
			q.push(node(x, y, 0));	//读入分店坐标，作为起点压入队列
		}
		for(int i=1, x, y, c; i<=k; mmp[x][y]=1, i++)	//mmp[x][y]=1表示客户
		{
			scanf("%d%d%d", &x, &y, &c);
			++cnt[x][y], tot[x][y]+=c;	//cnt[x][y]表示该点的客户数量，tot[x][y]表示该点的总订餐数
		}

		for(int i=1, x, y; i<=d; mmp[x][y]=-1, i++)	scanf("%d%d", &x, &y);	//mmp[x][y]=-1表示障碍

		printf("%lld\n", Bfs());
	}
	return 0;
}
```



# CCF-CSP  201409-5 拼图

## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 3.0s | 256.0MB |

**题目描述**

　　给出一个 $n×m$ 的方格图，现在要用如下 $L$ 型的积木拼到这个图中，使得方格图正好被拼满，请问总共有多少种拼法。其中，方格图的每一个方格正好能放积木中的一块。积木可以任意旋转。
![](201409-5-1.png)

**输入格式**

　　输入的第一行包含两个整数 $n, m$ ，表示方格图的大小。

**输出格式**

　　输出一行，表示可以放的方案数，由于方案数可能很多，所以请输出方案数除以1,000,000,007的余数。

**样例输入**

```
6 2
```

**样例输出**

```
4
```

**样例说明**

　　四种拼法如下图所示：
![](201409-5-2.PNG)

**评测用例规模与约定**

　　在评测时将使用10个评测用例对你的程序进行评测。
　　评测用例1和2满足：$1\leq n\leq 30，m=2$。
　　评测用例3和4满足：$1\leq n, m\leq 64$。
　　评测用例5满足：$1\leq n\leq 100，1\leq m\leq 6$。
　　评测用例6和7满足：$1\leq n\leq 1000，1\leq m\leq 6$。
　　评测用例8、9和10满足：$1\leq n\leq 10^{15}，1\leq m\leq 7$。

## 2、题解

## 3、参考程序

```

```



# CCF-CSP  201412-4 最优灌溉

## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 1.0s | 256.0MB |

**题目描述**

　　雷雷承包了很多片麦田，为了灌溉这些麦田，雷雷在第一个麦田挖了一口很深的水井，所有的麦田都从这口井来引水灌溉。
　　为了灌溉，雷雷需要建立一些水渠，以连接水井和麦田，雷雷也可以利用部分麦田作为“中转站”，利用水渠连接不同的麦田，这样只要一片麦田能被灌溉，则与其连接的麦田也能被灌溉。
　　现在雷雷知道哪些麦田之间可以建设水渠和建设每个水渠所需要的费用（注意不是所有麦田之间都可以建立水渠）。请问灌溉所有麦田最少需要多少费用来修建水渠。

**输入格式**

　　输入的第一行包含两个正整数 $n, m$ ，分别表示麦田的片数和雷雷可以建立的水渠的数量。麦田使用1, 2, 3, ……依次标号。
　　接下来 $m$ 行，每行包含三个整数 $a_i, b_i, c_i$，表示第 $a_i$ 片麦田与第 $b_i$ 片麦田之间可以建立一条水渠，所需要的费用为 $c_i$。

**输出格式**

　　输出一行，包含一个整数，表示灌溉所有麦田所需要的最小费用。

**样例输入**

```
4 4
1 2 1
2 3 4
2 4 2
3 4 3
```

**样例输出**

```
6
```

**样例说明**

　　建立以下三条水渠：麦田1与麦田2、麦田2与麦田4、麦田4与麦田3。

**评测用例规模与约定**

　　前20%的评测用例满足：$n≤5$。
　　前40%的评测用例满足：$n≤20$。
　　前60%的评测用例满足：$n≤100$。
　　所有评测用例都满足：$1≤n≤1000，1≤m≤100,000，1≤c_i≤10,000$。

## 2、题解

**最小生成树(MST - Minimum Spanning Tree，下文简称MST)**

1. 假设在一给定的无向图 $G = (V, E)$ 中，$(u, v)$ 代表连接顶点 $u$ 与顶点 $v$ 的边，而 $w(u, v)$ 代表此边的权重。简单来说，若选定子图 $T = (V, E')$，满足 $T$ 是无环无重边的连通图，则称 $T$ 是 $G$ 的生成树。
2. 令 $C(T)=∑w(u, v)((u, v)∈E')$，$G$ 的所有生成树中满足 $C(T)$ 最小的生成树称为 $G$ 的最小生成树。
3. 最小生成树其实是最小权重生成树的简称，每个无向图的最小生成树可能不唯一。

**并查集**

　　并查集是一种树型的数据结构，顾名思义就是有“合并集合”和“查找集合”两种操作的一种算法，用于处理一些不相交集合的合并及查询问题。若我们用集合中的某个元素来代表这个集合，该元素称为集合的代表元，判断两个元素是否属于同一集合，只需要看他们的代表元是否相同即可。算法大致流程如下：
1. 我们将一个集合内的所有元素组织成以代表元为根的树形结构，对于每一个元素 $x$，$fa[x]$ 指向 $x$ 在树形结构上的父亲节点，若 $x$ 是根节点，则令 $fa[x]=x$。
2. 对于查找操作，假设需要确定 $x$ 所在集合的代表元，可以沿着 $fa[x]$ 不断在树形结构中向上移动直到到达根节点。
3. 为了提高查找效率，查找时可以将 $x$ 到根节点路径上的所有点的 $fa$ 设为根节点，这种优化方法称为路经压缩。
4. 对于合并操作，假设需要将 $x$ 和 $y$ 所在的两个集合进行合并，只需要将 $x$ 或 $y$ 的根的 $fa$ 设置为另一个集合的根即可

**Kruskal**

　　Kruskal算法是一种用来寻找MST的算法，算法流程如下：
1. 首先将图 $G(V, E)$ 的各边按照权值进行排序。
2. 遍历所有边取出当前权值最小的边，若当前边和已加入最小生成树集合 $T$ 的边不冲突即不构成环，则将当前边加入集合 $T$，否则舍弃当前边。
3. 重复步骤二直到 $|T|=|V|-1$，此时得到的集合 $T$ 就是原图的最小生成树。

　　如何判定当前边与已选定的集合会不会成环？一个简单直接的想法是，假设当前边为 $(u, v)$，若 $u$ 和 $v$ 在集合 $T$ 中已经连通，那边 $(u, v)$ 就和集合 $T$ 冲突。

　　那怎样判定两个点是否联通呢？直接由 $u$ 出发进行深度优先搜索是可行的，但这个方法显然成本太高。这里我们使用并查集，现在我们重新梳理Kruskal算法的流程。

1. 首先将图 $G(V, E)$ 的各边按照权值进行排序，对于任意顶点 $v$，$fa[v]$ 初始为 $v$。
2. 遍历所有边取出当前权值最小边 $(u, v)$，查找 $u$ 和 $v$ 所在集合的代表元分别记为 $fu$ 和 $fv$，若 $fu$ 和 $fv$ 相等即 $u、v$ 在同一集合(已经连通)，说明当前边产生冲突应该将其舍弃，否则将当前边加入最小生成树集合 $T$，并合并 $u$ 和 $v$。
3. 重复步骤二直到 $|T|=|V|-1$，此时得到的集合 $T$ 就是原图的最小生成树。

**本题分析**

　　回到本题，将麦田作为顶点、水渠作为边建图，再执行Kruskal算法，得到的MST的所有边的权值和即最终答案。

## 3、参考程序

```C++
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<queue>
#include<algorithm>
using namespace std;
const int maxn=1000+10, maxm=1000000+10;

int n, m, fa[maxn];
struct node
{
	int u, v, c;
	node(int _u=0, int _v=0, int _c=0)
	{
		u=_u, v=_v, c=_c;
	}
	bool operator <(const node&t)const
	{
		return c>t.c;
	}
};
priority_queue<node> q;

int Find(int x)	//寻找x的根
{
	return x==fa[x] ? x : (fa[x]=Find(fa[x]));
}

long long Work()	//Kurskal
{
	int cnt=1;
	long long ans=0;

	for(int i=1; i<=n; i++) fa[i]=i;
	while(cnt<n)
	{
		int u=Find(q.top().u), v=Find(q.top().v), c=q.top().c;	
		//寻找当前边两个顶点的根
		q.pop();

		if(u==v)	continue;	//u、v已经在同一集合
		++cnt, ans+=c;
		fa[max(u, v)]=min(u, v);	//合并两个集合，此处将编号大的集合加入编号小的集合
	}

	return ans;
}

int main()
{
	while(scanf("%d%d", &n, &m)!=EOF)
	{
		while(!q.empty())	q.pop();
		for(int i=1, u, v, c; i<=m; i++)
		{
			scanf("%d%d%d", &u, &v, &c);
			q.push(node(u, v, c));
		}
		printf("%lld\n", Work());
	}
	return 0;
}
```



# CCF-CSP  201412-5 货物调度

## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 1.0s | 256.0MB |

**题目描述**

　　某公司要处理一个周期性的物流问题。
　　有 $n$ 个城市，第 $i$ 个城市在每周的第 $j(1≤j≤7)$ 天会生产 $a_{ij}$ 吨某种货物，同时需要消耗 $b_{ij}$ 吨该种货物。已知每周的产量等于消耗量（即 $a_{ij}$ 之和等于 $b_{ij}$ 之和）。
　　城市之间有 $m$ 条道路，第 $k$ 条道路连接了城市 $s_k$ 和 $t_k$ 。一条道路上运输1吨货物有一个固定的成本 $c_k$ 。道路都可以双向使用。每天运输的货物量没有限制。城市之间的距离并不远，货物可以从任意一个城市运输到任意另一个城市并且在当天到达。
　　货物如果在当天没有被消耗掉，就需要存放在仓库里过夜。第 $i$ 个城市的仓库容量为 $v_i$ ，存放1 吨货物过一夜所需的成本是 $w_i$ 。
　　请你计算该公司如果每周循环性地按照一个固定的流程调度货物的话，该公司在最优方案下每周需要为货物的运输和存储消耗多少成本。

**输入格式**

　　输入的第一行有两个正整数 $n$ 和 $m$，即城市的个数和道路的条数。
　　接下来有 $n$ 行，每行包含16个整数，用以描述第 $i$ 个城市的相关数据。其中第 $i$ 行包含的数为 $a_{i1}, a_{i2}, a_{i3}, a_{i4}, a_{i5}, a_{i6}, a_{i7}, b_{i1}, b_{i2}, b_{i3}, b_{i4}, b_{i5}, b_{i6}, b_{i7}, v_i, w_i$。
　　接下来有 $m$ 行，每行包含3个整数，用以描述一条道路的相关数据。其中第 $k$ 行包含的数为 $s_k, t_k$ 和 $c_k$ 。
　　输入数据中城市的编号均为1到 $n$ 之间。输入数据的每行的行首行尾均保证没有空格，两个数之间恰好被一个空格隔开。

**输出格式**

　　你只需要输出一个数，即最优方案下每周的支出。

**样例输入**

```
3 3
0 0 0 0 5 0 0 0 0 0 0 0 0 0 2 4
0 0 0 0 0 0 0 2 0 0 0 0 0 0 2 1
0 0 0 0 0 0 0 0 0 3 0 0 0 0 2 5
1 2 1
1 3 5
2 3 1
```

**样例输出**

```
67
```

**样例说明**

　　城市1 每周五生产5 吨货物，把其中2 吨运到存储费用低廉的城市2 存储，把1 吨运到城市3 存储，剩下的2 吨留在城市1。
　　在次周一的时候城市2 会消耗掉存放在那里的2 吨货物。为了节约存储成本，将囤放在城市1 的货物运到城市2 存放。周三再将所有货物运到城市3 以满足该城市的需求。
　　在此方案下，每周的运输成本为8，每周的存储成本为59，因此每周的总支出为67。

**评测用例规模与约定**

　　对于100%的数据，$1≤n≤100，1≤m≤500，0≤a_{ij},b_{ij},v_i≤100，1≤w_i,c_k≤100$。

## 2、题解

## 3、参考程序

```

```



# CCF-CSP  201503-4 网络延时

## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 1.0s | 256.0MB |

**题目描述**

　　给定一个公司的网络，由 $n$ 台交换机和 $m$ 台终端电脑组成，交换机与交换机、交换机与电脑之间使用网络连接。交换机按层级设置，编号为1的交换机为根交换机，层级为1。其他的交换机都连接到一台比自己上一层的交换机上，其层级为对应交换机的层级加1。所有的终端电脑都直接连接到交换机上。
　　当信息在电脑、交换机之间传递时，每一步只能通过自己传递到自己所连接的另一台电脑或交换机。请问，电脑与电脑之间传递消息、或者电脑与交换机之间传递消息、或者交换机与交换机之间传递消息最多需要多少步。

**输入格式**

　　输入的第一行包含两个整数 $n, m$ ，分别表示交换机的台数和终端电脑的台数。
　　第二行包含 $n - 1$ 个整数，分别表示第2、3、……、$n$ 台交换机所连接的比自己上一层的交换机的编号。第 $i$ 台交换机所连接的上一层的交换机编号一定比自己的编号小。
　　第三行包含 $m$ 个整数，分别表示第1、2、……、$m$ 台终端电脑所连接的交换机的编号。

**输出格式**

　　输出一个整数，表示消息传递最多需要的步数。

**样例输入**

```
4 2
1 1 3
2 1
```

**样例输出**

```
4
```

**样例说明**

　　样例的网络连接模式如下，其中圆圈表示交换机，方框表示电脑：
![](201503-4.png)
　　其中电脑1与交换机4之间的消息传递花费的时间最长，为4个单位时间。

**样例输入**

```
4 4
1 2 2
3 4 4 4
```

**样例输出**

```
4
```

**样例说明**

​	样例的网络连接模式如下：
![](201503-4-2.png)
　　其中电脑1与电脑4之间的消息传递花费的时间最长，为4个单位时间。

**评测用例规模与约定**

　　前30%的评测用例满足：$n ≤ 5, m ≤ 5$。
　　前50%的评测用例满足：$n ≤ 20, m ≤ 20$。
　　前70%的评测用例满足：$n ≤ 100, m ≤ 100$。
　　所有评测用例都满足：$1 ≤ n ≤ 10000，1 ≤ m ≤ 10000$。

## 2、题解

**树的直径**

　　树的直径是指树的简单最长路，求法也同样很简单：先任选一个起点进行搜索(DFS和BFS均可)找到最长路的终点，再从终点进行第二次搜索，这次找到的最长路即为树的直径。关于这个做法的正确性，同学可以尝试用反证法进行证明。
　　
**本题分析**

　　在本题中，所有电脑和交换机通过网络连接成为树形结构，所求的就是树的直径。

## 3、参考程序

```C++
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const int maxn=20000+10;

int n, m, root, dis[maxn];
int cur, fir[maxn], nxt[maxn<<1], ver[maxn<<1];
bool vis[maxn];

void Add(int u, int v)
{
	ver[++cur]=v, nxt[cur]=fir[u], fir[u]=cur;
	ver[++cur]=u, nxt[cur]=fir[v], fir[v]=cur;
	return ;
}

void Dfs(int u, int d)
{
	vis[u]=true;
	dis[u]=d;
	if(d>dis[root])	root=u;	//root保存搜索找到的最长路的终点

	for(int i=fir[u], v; i; i=nxt[i]) if(!vis[v=ver[i]])	Dfs(v, d+1);
	return ;
}

int main()
{
	while(scanf("%d%d", &n, &m)!=EOF)
	{
		cur=0;
		memset(fir, 0, sizeof fir);
		for(int i=2, x; i<=n; i++)
		{
			scanf("%d", &x);
			Add(i, x);
		}
		for(int i=1, x; i<=m; i++)
		{
			scanf("%d", &x);
			Add(i+n, x);	//交换机的编号n+1~m
		}

		root=0;
		memset(dis, 0, sizeof dis);
		memset(vis, false, sizeof vis);
		Dfs(1, 0);		//从任意节点出发，将找到最长路的终点保存在root里
		
		int tmp=root;	//保存上一次最长路的终点
		root=0;
		memset(dis, 0, sizeof dis);
		memset(vis, false, sizeof vis);
		Dfs(tmp, 0);	//从上一次最长路的终点出发，找到新的最长路的终点，二者之间的距离即为树的直径
		printf("%d\n", dis[root]);
	}
	return 0;
}
```



# CCF-CSP  201503-5 最小花费

## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 4.0s | 256.0MB |

**题目描述**

　　C国共有 $n$ 个城市。有 $n-1$ 条双向道路，每条道路连接两个城市，任意两个城市之间能互相到达。小R来到C国旅行，他共规划了 $m$ 条旅行的路线，第 $i$ 条旅行路线的起点是 $s_i$ ，终点是 $t_i$ 。在旅行过程中，小R每行走一单位长度的路需要吃一单位的食物。C国的食物只能在各个城市中买到，而且不同城市的食物价格可能不同。
　　然而，小R不希望在旅行中为了购买较低价的粮食而绕远路，因此他总会选择最近的路走。现在，请你计算小R规划的每条旅行路线的最小花费是多少。

**输入格式**

　　第一行包含2个整数 $n$ 和 $m$。
　　第二行包含 $n$ 个整数。第 $i$ 个整数 $w_i$ 表示城市i的食物价格。
　　接下来 $n-1$ 行，每行包括3个整数 $u, v, e$，表示城市 $u$ 和城市 $v$ 之间有一条长为 $e$ 的双向道路。
　　接下来 $m$ 行，每行包含2个整数 $s_i$ 和 $t_i$，分别表示一条旅行路线的起点和终点。

**输出格式**

　　输出 $m$ 行，分别代表每一条旅行方案的最小花费。

**样例输入**

```
6 4
1 7 3 2 5 6
1 2 4
1 3 5
2 4 1
3 5 2
3 6 1
2 5
4 6
6 4
5 6
```

**样例输出**

```
35
16
26
13
```

**样例说明**

　　对于第一条路线，小R会经过 $2->1->3->5$ 。其中在城市2处以7的价格购买4单位粮食，到城市1时全部吃完，并用1的价格购买7单位粮食，然后到达终点。

**评测用例规模与约定**

　　前10%的评测用例满足：$n, m ≤ 20, w_i ≤ 20$；
　　前30%的评测用例满足：$n, m ≤ 200$；
　　另有40%的评测用例满足：一个城市至多与其它两个城市相连。
　　所有评测用例都满足：$1 ≤ n, m ≤ 10^5，1 ≤ w_i ≤ 10^6，1 ≤ e ≤ 10000$。

## 2、题解

## 3、参考程序

```

```



# CCF-CSP  201509-4 高速公路

## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 1.0s | 256.0MB |

**题目描述**

　　某国有 $n$ 个城市，为了使得城市间的交通更便利，该国国王打算在城市之间修一些高速公路，由于经费限制，国王打算第一阶段先在部分城市之间修一些单向的高速公路。
　　现在，大臣们帮国王拟了一个修高速公路的计划。看了计划后，国王发现，有些城市之间可以通过高速公路直接（不经过其他城市）或间接（经过一个或多个其他城市）到达，而有的却不能。如果城市A可以通过高速公路到达城市B，而且城市B也可以通过高速公路到达城市A，则这两个城市被称为便利城市对。
　　国王想知道，在大臣们给他的计划中，有多少个便利城市对。

**输入格式**

　　输入的第一行包含两个整数 $n, m$ ，分别表示城市和单向高速公路的数量。
　　接下来 $m$ 行，每行两个整数 $a, b$ ，表示城市 $a$ 有一条单向的高速公路连向城市 $b$。

**输出格式**

　　输出一行，包含一个整数，表示便利城市对的数量。

**样例输入**

```
5 5
1 2
2 3
3 4
4 2
3 5
```

**样例输出**

```
3
```

**样例说明**

　　城市间的连接如图所示。有3个便利城市对，它们分别是(2, 3), (2, 4), (3, 4)，请注意(2, 3)和(3, 2)看成同一个便利城市对。
![](201509-4.png)

## 2、题解

**强连通图**

1.  在有向图中，如果两个顶点可以相互通达，则称两个顶点强连通(strongly connected)。
2.  如果有向图 $G$ 的每两个顶点都强连通，称 $G$ 是一个强连通图。
3.  有向图的极大强连通子图，称为强连通分量(strongly connected components)。

**Tarjan**

　　Tarjan算法是一种求解有向图强连通分量的线性时间的算法，是基于对图深度优先搜索的算法，它基于定理：在任何深度优先搜索中，同一强连通分量内的所有顶点均在同一棵深度优先搜索树中，也就是说，强连通分量一定是有向图的某个深搜树子树。

　　我们准备两个数组 $low$ 和 $dfn$。$dfn$ 数组实质是一个时间戳，记录搜索到该点的时间，$low$ 数组是一个标记数组，记录该点所在的强连通子图所在搜索子树的根节点的 $dfn$ 值。可以证明，当一个点既是强连通子图 $A$ 中的点，又是强连通子图 $B$ 中的点，则它是强连通子图 $A∪B$ 中的点。这样，我们用 $low$ 值记录该点所在强连通子图对应的搜索子树的根节点的 $dfn$ 值。注意，该子树中的元素在栈中一定是相邻的，且根节点在栈中一定位于所有子树元素的最下方。强连通分量是由若干个环组成的。所以，当有环形成时（也就是搜索的下一个点已在栈中），我们将这一条路径的 $low$ 值统一，即这条路径上的点属于同一个强连通分量。如果遍历完整个搜索树后某个点的 $dfn$ 值等于 $low$ 值，则它是该搜索子树的根。这时，它以上（包括它自己）一直到栈顶的所有元素组成一个强连通分量。

　　具体来说，Tarjan算法的实现流程如下：

1.  当首次搜索到点 $u$ 时，$dfn$ 与 $low$ 数组的值都为到该点的时间，且将 $u$ 压入栈顶。
2.  对于 $u$ 的邻接点 $v$，如果此时 $v$ 没被访问过，访问 $v$，修改 $low[u]=min(low[u]和low[v])$，如果此时 $v$ 已被访问过且仍在栈中，修改 $low[u]=(low[u]和low[v])$（另一种写法是 $low[u]=Min(low[u], dfn[v])$，两种写法所得的 $low[u]$ 不同，但 $dfn[v]$ 和 $low[v]$ 均小于 $low[u]$，而算法实质上需要寻找的是 $dfn$ 等于 $low$ 的节点，所以任何一种写法对整体结果都不产生影响）。
3.  遍历完 $u$ 的所有邻接点时，若 $dfn[u]$ 和 $low[u]$ 相等，则将它以及在它之上的元素全部弹出栈，这些元素组成一个强连通分量。重复以上步骤直到访问完图中所有节点。

**本题分析**

　　回到本题，我们只需要在建图后求出各强连通分量的顶点数 $m$，求出 $∑C(m, 2)$ 即是所求答案。

## 3、参考程序

```C++
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<vector>
#include<cstdio>
#include<cmath>
#include<stack>
#include<algorithm>
using namespace std;
const int maxn=10000+10;

int n, m, idx, tot, cnt[maxn], w[maxn], dfn[maxn], low[maxn];
bool ins[maxn];
stack<int> s;
vector<int> eg[maxn];

void Tarjan(int u)
{
	dfn[u]=low[u]=++idx;
	ins[u]=true;
	s.push(u);

	for(int i=0, len=eg[u].size(), v; i<len; i++)
	{
		v=eg[u][i];
		if(!dfn[v])
		{
			Tarjan(v);
			low[u]=min(low[u], low[v]);
		}
		else if(ins[v])	low[u]=min(low[u], low[v]);
	}

	if(dfn[u]==low[u])
	{
		int v=s.top();
		s.pop();

		w[v]=++tot, ins[v]=false;
		while(v!=u)
		{
			v=s.top();
			s.pop();
			w[v]=tot, ins[v]=false;
		}
	}
	return ;
}

int main()
{
	while(scanf("%d%d", &n, &m)!=EOF)
	{
		idx=tot=0;
		memset(w, 0, sizeof w);
		memset(dfn, 0, sizeof dfn);
		memset(low, 0, sizeof low);
		memset(cnt, 0, sizeof cnt);
		memset(ins, false, sizeof ins);
		for(int i=1; i<=n; i++)	eg[i].clear();

		for(int i=1, u, v; i<=m; i++)
		{
			scanf("%d%d", &u, &v);
			eg[u].push_back(v);
		}

		for(int i=1; i<=n; i++)	if(!dfn[i])	Tarjan(i);

		int ans=0;
		for(int i=1; i<=n; i++) ++cnt[w[i]];	//计算每个强连通分量内的顶点数
		for(int i=1; i<=tot; i++)	if(cnt[i]>1)	ans+=cnt[i]*(cnt[i]-1)/2;	//该连通分量中任意两个点均可以互相到达
		printf("%d\n", ans);
	}
	return 0;
}
```



# CCF-CSP  201509-5 最佳文章

## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 1.0s | 256.0MB |

**题目描述**

　　小明最近在研究一门新的语言，叫做Q语言。Q语言单词和文章都可以用且仅用只含有小写英文字母的字符串表示，任何由这些字母组成的字符串也都是一篇合法的Q语言文章。
　　在Q语言的所有单词中，小明选出了他认为最重要的 $n$ 个。使用这些单词，小明可以评价一篇Q语言文章的“重要度”。
　　文章“重要度”的定义为：在该文章中，所有重要的Q语言单词出现次数的总和。其中多次出现的单词，不论是否发生包含、重叠等情况，每次出现均计算在内。
　　例如，假设 $n = 2$ ，小明选出的单词是 $gvagv$ 和 $agva$。在文章 $gvagvagvagv$ 中，$gvagv$ 出现了3次，$agva$ 出现了2次，因此这篇文章的重要度为 3+2=5。
　　现在，小明想知道，一篇由 $m$ 个字母组成的Q语言文章，重要度最高能达到多少。

**输入格式**

　　输入的第一行包含两个整数 $n, m$，表示小明选出的单词个数和最终文章包含的字母个数。
　　接下来 $n$ 行，每行包含一个仅由英文小写字母构成的字符串，表示小明选出的这 $n$ 个单词。

**输出格式**

　　输出一行一个整数，表示由 $m$ 个字母组成的Q语言文章中，重要度最高的文章的重要度。

**样例输入**

```
3 15
agva
agvagva
gvagva
```

**样例输出**

```
11
```

**样例说明**

　　15个字母组成的重要度最高的文章为 $gvagvagvagvagva$。
　　在这篇文章中，$agva$ 出现4次，$agvagva$ 出现3次，$gvagva$ 出现4次，共计4+3+4=11次。

**评测用例规模与约定**

　　在评测时将使用10个评测用例对你的程序进行评测。
　　设 $s$ 为构成 $n$ 个重要单词字母的总个数，例如在样例中，$s=4+7+6=17$；$a$ 为构成 $n$ 个重要单词字母的种类数，例如在样例中，共有3中字母'a','g','v'，因此 $a=3$ 。
　　评测用例1和2满足 $2 ≤ n ≤ 3，1500 ≤ m ≤ 2000，s = 40$；
　　评测用例3和4满足 $m = 20，2 ≤ a ≤ 3$；
　　评测用例5、6和7满足 $2000 ≤ m ≤ 100000$；
　　评测用例8满足 $n = 2$；
　　所有的评测用例满足 $1 ≤ s ≤ 100，1 ≤ m ≤ 10^{15}$，每个单词至少包含1个字母，保证单词中仅出现英文小写字母，输入中不含多余字符，不会出现重复的单词。

## 2、题解

## 3、参考程序

```

```



# CCF-CSP  201512-4 送货

## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 1.0s | 256.0MB |

**题目描述**

　　为了增加公司收入，F公司新开设了物流业务。由于F公司在业界的良好口碑，物流业务一开通即受到了消费者的欢迎，物流业务马上遍及了城市的每条街道。然而，F公司现在只安排了小明一个人负责所有街道的服务。
　　任务虽然繁重，但是小明有足够的信心，他拿到了城市的地图，准备研究最好的方案。城市中有 $n$ 个交叉路口，$m$ 条街道连接在这些交叉路口之间，每条街道的首尾都正好连接着一个交叉路口。除开街道的首尾端点，街道不会在其他位置与其他街道相交。每个交叉路口都至少连接着一条街道，有的交叉路口可能只连接着一条或两条街道。
　　小明希望设计一个方案，从编号为1的交叉路口出发，每次必须沿街道去往街道另一端的路口，再从新的路口出发去往下一个路口，直到所有的街道都经过了正好一次。

**输入格式**

　　输入的第一行包含两个整数 $n, m$，表示交叉路口的数量和街道的数量，交叉路口从1到 $n$ 标号。
　　接下来 $m$ 行，每行两个整数 $a, b$，表示和标号为 $a$ 的交叉路口和标号为 $b$ 的交叉路口之间有一条街道，街道是双向的，小明可以从任意一端走向另一端。两个路口之间最多有一条街道。

**输出格式**

　　如果小明可以经过每条街道正好一次，则输出一行包含 $m+1$ 个整数 $p_1, p_2, p_3, ..., p_{m+1}$，表示小明经过的路口的顺序，相邻两个整数之间用一个空格分隔。如果有多种方案满足条件，则输出字典序最小的一种方案，即首先保证 $p_1$ 最小，$p_1$ 最小的前提下再保证 $p_2$ 最小，依此类推。
　　如果不存在方案使得小明经过每条街道正好一次，则输出一个整数-1。

**样例输入**

```
4 5
1 2
1 3
1 4
2 4
3 4
```

**样例输出**

```
1 2 4 1 3 4
```

**样例说明**

　　城市的地图和小明的路径如下图所示。
![](201512-4.png)

**样例输入**

```
4 6
1 2
1 3
1 4
2 4
3 4
2 3
```

**样例输出**

```
-1
```

**样例说明**

　　城市的地图如下图所示，不存在满足条件的路径。
![](201512-4-2.png)

## 2、题解

**欧拉路径**

1.  若图G中存在这样一条路径，使得它恰通过G中每条边一次,则称该路径为**欧拉路径**。
2.  在一个简单无向连通图中，若所有顶点的度数均为偶数，则该图存在欧拉回路，若有且仅有A、B两点的度数为奇数，则存在以A、B为起终点的欧拉路径，否则，该图不存在欧拉路径。

**本题分析**

　　简单来说，本题需要判断给定的无向图是否存在以顶点1为起点的欧拉路径，如果存在，输出字典序最小的路径。我们先判断是否存在符合条件的欧拉路径，如果存在，从顶点1出发进行DFS即可得到相应的欧拉路径，而字典序最小的要求，只需要在搜索时遍历按字典序排序后的邻接点即可满足。

## 3、参考程序

```C++
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<vector>
#include<cmath>
#include<stack>
#include<map>
#include<algorithm>
using namespace std;
const int maxn=10000+10;
#define mp(a, b) make_pair(a, b)

int n, m, du[maxn];
bool vis[maxn], flag[maxn][maxn];
vector<int> vec[maxn];
stack<int> s;

void Add(int u, int v)
{
	vec[u].push_back(v), vec[v].push_back(u);
	++du[u], ++du[v];
	return ;
}

void Dfs(int u)
{
	vis[u]=true;
	for(int i=0, v; i<vec[u].size(); i++) if(!vis[v=vec[u][i]])	Dfs(v);
	return ;
}

bool Read()
{
	for(int i=1, u, v; i<=m; i++)
	{
		scanf("%d%d", &u, &v);
		Add(u, v);
	}
	Dfs(1);	//先深搜，判断图是否联通

	int cnt=0;
	for(int i=1; i<=n; i++)
	{
		sort(vec[i].begin(), vec[i].end());	//将i点的所有邻接边按顶点编号排序
		if(!vis[i])	return false;	//如果vis[i]为假，表示从1出发不能到达i，那原图不联通，不存在欧拉图
		if(du[i]&1)	++cnt;	//奇点的数量
	}
	if(cnt!=0 && cnt!=2)	return false;	//如果有奇点且奇点数不为2，则不存在欧拉图
	if(cnt==2 && !(du[1]&1))	return false;	//有两个奇点但编号1为偶点，那1不能作为起点，则不存在满足题意的欧拉图
	return true;
}

void Work(int u)
{
	for(int i=0; i<vec[u].size(); i++)
	{
		int v=vec[u][i];
		if(!flag[u][v])	//判断u到v的边有没有访问过
		{
			flag[u][v]=flag[v][u]=true;
			Work(v);
			s.push(v);	//压入堆栈
		}
	}
	return ;
}

int main()
{
	while(scanf("%d%d", &n, &m)!=EOF)
	{
		memset(du, 0, sizeof du);
		memset(vis, false, sizeof vis);
		memset(flag, false, sizeof flag);
		while(!s.empty())	s.pop();
		for(int i=1; i<=n; i++)	vec[i].clear();

		if(Read())
		{
			Work(1);
			printf("1");
			while(!s.empty())
			{
				printf(" %d", s.top());
				s.pop();
			}
			printf(" \n");
		}
		else printf("-1\n");	//读入时已经判断不能形成欧拉图，输出-1
	}
	return 0;
}
```



# CCF-CSP  201512-5 矩阵

## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 1.0s | 256.0MB |

**题目描述**

　　创造一个世界只需要定义一个初状态和状态转移规则。
　　宏观世界的物体运动规律始终跟物体当前的状态有关，也就是说只要知道物体足够多的状态信息，例如位置、速度等，我们就能知道物体之后任意时刻的状态。
　　现在小M创造了一个简化的世界。
　　这个世界中，时间是离散的，物理规律是线性的：世界的初始状态可以用一个 $m$ 维向量 $b^{(0)}$ 表示，状态的转移方式用 $m×m$ 的矩阵 $A$ 表示。
　　若已知这个世界当前的状态是 $b$，那么下一时刻就等于 $b$ 左乘状态转移矩阵 $A$，即 $Ab$ 。
　　这个世界中，物体的状态也是离散的，也就是说可以用整数表示。再进一步，整数都可以用二进制编码拆分为有限位0和1。因此，这里的矩阵 $A$ 和向量 $b$ 的每个元素都是0或1，矩阵乘法中的加法运算视为异或运算（$xor$），乘法运算视为与运算（$and$）。
　　具体地，设矩阵 $A$ 第 $i$ 行第 $j$ 列的元素为 $a_{i, j}$，向量 $b$ 的第 $i$ 个元素为 $b_i$。那么乘法 $Ab$ 所得的第 $k$ 个元素为
　　$(a_{k,1}\ and\ b_1)\ xor\ (a_{k,2}\ and\ b_2)\ xor\ ⋯\ xor\ (a_{k,m}\ and\ b_m)$
　　矩阵和矩阵的乘法也有类似的表达。
　　小M发现，这样的矩阵运算也有乘法结合律，例如有 $A(Ab)=(AA)b=A^2b$。
　　为了保证自己创造的世界维度不轻易下降，小M保证了矩阵 $A$ 可逆，也就是说存在一个矩阵 $A^{-1}$，使得对任意向量 $d$，都有 $A^{-1}Ad=d$。
　　小M想了解自己创造的世界是否合理，他希望知道这个世界在不同时刻的状态。
　　具体地，小M有 $n$ 组询问，每组询问会给出一个非负整数 $k$ ，小M希望你帮他求出 $A^kb$。

**输入格式**

　　输入第一行包含一个整数 $m$，表示矩阵和向量的规模。
　　接下来 $m$ 行，每行包含一个长度为 $m$ 的01串，表示矩阵 $A$。
　　接下来一行，包含一个长度为 $m$ 的01串，表示初始向量 $b^{(0)}$ 。（$b^{(0)}$ 是列向量，这里表示它的转置）
　　注意：01串两个相邻的数字之间均没有空格。
　　接下来一行，包含一个正整数 $n$，表示询问的个数。
　　最后 $n$ 行，每行包含一个非负整数 $k$，表示询问 $A^kb^{(0)}$。
　　注意：$k$ 可能为0，此时是求$A^0b^{(0)} =b^{(0)}$。

**输出格式**

　　输出 $n$ 行，每行包含一个01串，表示对应询问中 $A^kb^{(0)}$ 的结果。
　　注意：01串两个相邻的数字之间不要输出空格。

**样例输入**

```
3
110
011
111
101
10
0
2
3
14
1
1325
6
124124
151
12312
```

**样例输出**

```
101
010
111
101
110
010
100
101
001
100
```

**评测用例规模与约定**

　　本题使用10个评测用例来测试你的程序。
　　对于评测用例1，$m = 10，n = 100，k ≤ 10^3$。
　　对于评测用例2，$m = 10，n = 100，k ≤ 10^4$。
　　对于评测用例3，$m = 30，n = 100，k ≤ 10^5$。
　　对于评测用例4，$m = 180，n = 100，k ≤ 10^5$。
　　对于评测用例5，$m = 10，n = 100，k ≤ 10^9$。
　　对于评测用例6，$m = 30，n = 100，k ≤ 10^9$。
　　对于评测用例7，$m = 180，n = 100，k ≤ 10^9$。
　　对于评测用例8，$m = 600，n = 100，k ≤ 10^9$。
　　对于评测用例9，$m = 800，n = 100，k ≤ 10^9$。
　　对于评测用例10，$m = 1000，n = 100，k ≤ 10^9$。

## 2、题解

## 3、参考程序

```

```



# CCF-CSP  201604-4 游戏

## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 1.0s | 256.0MB |

**题目描述**

　　小明在玩一个电脑游戏，游戏在一个 $n×m$ 的方格图上进行，小明控制的角色开始的时候站在第一行第一列，目标是前往第 $n$ 行第 $m$ 列。
　　方格图上有一些方格是始终安全的，有一些在一段时间是危险的，如果小明控制的角色到达一个方格的时候方格是危险的，则小明输掉了游戏，如果小明的角色到达了第 $n$ 行第 $m$ 列，则小明过关。第一行第一列和第 $n$ 行第 $m$ 列永远都是安全的。
　　每个单位时间，小明的角色必须向上下左右四个方向相邻的方格中的一个移动一格。
　　经过很多次尝试，小明掌握了方格图的安全和危险的规律：每一个方格出现危险的时间一定是连续的。并且，小明还掌握了每个方格在哪段时间是危险的。
　　现在，小明想知道，自己最快经过几个时间单位可以达到第 $n$ 行第 $m$ 列过关。

**输入格式**

　　输入的第一行包含三个整数 $n, m, t$，用一个空格分隔，表示方格图的行数 $n$、列数 $m$，以及方格图中有危险的方格数量。
　　接下来 $t$ 行，每行4个整数 $r, c, a, b$，表示第 $r$ 行第 $c$ 列的方格在第 $a$ 个时刻到第 $b$ 个时刻之间是危险的，包括 $a$ 和 $b$。游戏开始时的时刻为0。输入数据保证 $r$ 和 $c$ 不同时为1，而且当 $r$ 为 $n$ 时 $c$ 不为 $m$。一个方格只有一段时间是危险的（或者说不会出现两行拥有相同的 $r$ 和 $c$ ）。

**输出格式**

　　输出一个整数，表示小明最快经过几个时间单位可以过关。输入数据保证小明一定可以过关。

**样例输入**

```
3 3 3
2 1 1 1
1 3 2 10
2 2 2 10
```

**样例输出**

```
6
```

**样例说明**

　　第2行第1列时刻1是危险的，因此第一步必须走到第1行第2列。
　　第二步可以走到第1行第1列，第三步走到第2行第1列，后面经过第3行第1列、第3行第2列到达第3行第3列。

**评测用例规模与约定**

　　前30%的评测用例满足：$0 < n, m ≤ 10，0 ≤ t < 99$。
　　所有评测用例满足：$0 < n, m ≤ 100，0 ≤ t < 9999，1 ≤ r ≤ n，1 ≤ c ≤ m，0 ≤ a ≤ b ≤ 100$。

## 2、题解

**BFS**

**本题分析**

　　本题可以简单地采用BFS解决，只需要记录坐标 $(x, y)$ 在时刻 $p$ 是否被访问。因为本题数据规模较小，$n、m、a、b$ 均在100以内，可以知道在最坏情况下，100个时间单位以后全图都是安全点，最坏情况下也只需要 $n+m-2$ 步就可以到达终点，总时间仍然在300以内，空间存储上是允许的。

## 3、参考程序

```C++
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<queue>
#include<algorithm>
using namespace std;
const int maxn=100+10, maxm=500+10;

int n, m, k;
int l[maxn][maxn], r[maxn][maxn];
int dd[4][2]={0, 1, 0, -1, 1, 0, -1, 0};
bool vis[maxn][maxn][maxm];
//vis[i][j][k]记录点(i,j)在时刻k是否被访问
struct node
{
	int x, y, t;
	node(int _x=0, int _y=0, int _t=0)
	{
		x=_x, y=_y, t=_t;
	}
};
queue<node> q;

int Work()
{
	memset(vis, false, sizeof vis);
	while(!q.empty())	q.pop();

	vis[1][1][0]=true;
	q.push(node(1, 1, 0));

	while(!q.empty())
	{
		node u=q.front();
		q.pop();

		for(int i=0; i<4; i++)
		{
			int tx=u.x+dd[i][0], ty=u.y+dd[i][1], tt=u.t+1;
			if(tx<1 || tx>n || ty<1 || ty>m	|| vis[tx][ty][tt] || (l[tx][ty]<=tt && tt<=r[tx][ty]))	continue;
			if(tx==n && ty==m)	return tt;	//到达终点，返回所用的时间
			vis[tx][ty][tt]=true;
			q.push(node(tx, ty, tt));
		}
	}
	return 0;
}

int main()
{
	while(scanf("%d%d%d", &n, &m, &k)!=EOF)
	{
		memset(l, 0, sizeof l);
		memset(r, 0, sizeof r);

		for(int i=1, x, y, a, b; i<=k; i++)
		{
			scanf("%d%d%d%d", &x, &y, &a, &b);
			l[x][y]=a, r[x][y]=b;	//记录(x,y)点的危险时间范围
		}

		printf("%d\n", Work());
	}
	return 0;
}
```



# CCF-CSP  201604-5 网络连接

## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 5.0s | 256.0MB |

**题目描述**

　　某校新建的大楼中有 $n$ 台设备，学校需要利用这些设备搭建一个网络。我们用1到 $n$ 的整数给这些设备编号。
　　这些设备之间一共可以建立 $m$ 条连线，建立每条连线会消耗一定的费用。连接建立后两台设备就可以相互通信了。两台设备可以借助其他设备进行通信，即通信关系可传递：如果设备A和设备B都能与设备C相互通信，那么设备A和设备B也能相互通信。
　　由于大楼的拓扑结构所限，可以建立连线的两台设备，一定满足其编号之差的绝对值不超过 $p$ 。
　　这 $n$ 台设备中的一部分属于用户设备。学校要求在最终的网络中，用户设备必须两两能够相互通信，其他设备则可以根据需要选择连线或不连线。
　　现在问要达到学校的要求最少要消耗多少的费用。

**输入格式**

　　输入的第一行包含一个正整数 $T$，表示数据的组数，保证 $T=5$。接下来依次描述每组数据。
　　每组数据的第一行包含3个正整数 $n, m, p$，表示设备的总数，可以建立的连线数量和拓扑结构的参数。
　　第二行包含一个长度为 $n$ 的01字符串，依次表示这 $n$ 台设备是否为用户设备；为1表示是，为0表示不是。相邻字符之间无空格隔开，保证不会出现除了0和1之外的字符。保证至少有2个设备是用户设备。
　　接下来 $m$ 行，每行包含3个非负整数 $u, v, w$，表示设备 $u$ 和设备 $v$ 可以消耗 $w$ 的费用建立连线。其中 $0 < u < v ≤ n，v – u ≤ p，w ≤ 10^6$ 。
　　除第二行外，所有的数之间用一个空格隔开。
　　保证两台设备之间最多只有一条可以建立的连线，保证至少存在一种方案能够满足学校的要求。

**输出格式**

　　对于每组数据，输出一行一个整数，表示能达到要求所需的最少费用。

**样例输入**

```
1
20 11 6
10000100001100000000
1 6 300
1 3 100
3 6 100
4 10 100
4 6 100
6 10 400
10 15 100
11 15 100
10 11 500
12 15 100
15 20 100
```

**样例输出**

```
700
```

**样例说明**

　　用户设备分别是1、6、11、12。最优的方案需要选择以下连线：设备1和3，费用100；设备3和6，费用100；设备4和6，费用100；设备4和10，费用100；设备10和15，费用100；设备11和15，费用100；设备12和15，费用100。共计700。

**子任务**

　　每个测试点的每组数据分别都满足以下限制（其中c表示用户设备总数）：

| 编号   | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| $n$  | =500 | =500 | =500 | =500 | =500 | =500 | =500 | =500 | =500 | =500 |
| $p$  | =6   | =6   | =6   | =6   | =6   | =2   | =2   | =3   | =6   | =6   |
| $c$  | =$n$ | =2   | =4   | =6   | =8   | =10  | 无限制  | 无限制  | 无限制  | 无限制  |

**样例输入**

```
5
20 93 6
11111111111111111111
1 2 727765
2 3 263881
1 4 514909
2 4 131844
3 4 933178
1 5 438613
2 5 603733
3 5 859906
4 5 38725
1 6 599082
2 6 225184
3 6 365575
4 6 126126
5 6 25505
2 7 546601
3 7 63931
4 7 419406
5 7 531790
6 7 265271
2 8 724126
3 8 163879
4 8 59317
5 8 545880
6 8 126779
7 8 938859
4 9 387231
5 9 600880
6 9 927742
7 9 56690
8 9 987324
4 10 23106
5 10 328383
6 10 757082
7 10 787341
8 10 218539
9 10 282814
5 11 506005
6 11 257575
7 11 524808
8 11 223439
9 11 402018
10 11 580131
6 12 711292
7 12 314072
8 12 752595
9 12 141042
10 12 339498
11 12 321201
7 13 100337
8 13 969444
9 13 683912
10 13 973527
11 13 776443
12 13 436444
8 14 826460
9 14 453950
10 14 231374
11 14 667343
13 14 754318
10 15 46540
11 15 741941
12 15 909374
13 15 901791
14 15 246817
10 16 34192
11 16 866848
12 16 488324
13 16 824636
14 16 319615
15 16 472537
11 17 661823
12 17 595773
13 17 912773
14 17 674733
15 17 880787
16 17 168668
12 18 621903
13 18 894662
14 18 994829
15 18 80344
16 18 343121
17 18 697098
13 19 569872
14 19 599332
15 19 417377
16 19 837022
18 19 270641
14 20 748579
15 20 724926
16 20 367572
17 20 103857
18 20 443540
19 20 932348
20 92 6
00000010000000001000
1 2 113099
1 3 587351
2 3 209419
1 4 412024
2 4 526550
3 4 74575
1 5 627809
2 5 488889
3 5 78667
4 5 853953
1 6 914999
2 6 60305
3 6 52666
4 6 39394
5 6 243622
1 7 843636
2 7 752452
3 7 206953
4 7 209536
5 7 105503
6 7 179097
2 8 938375
3 8 449664
4 8 464591
5 8 312120
6 8 943383
7 8 798642
3 9 759837
4 9 655902
5 9 367024
6 9 560174
7 9 421235
8 9 552637
4 10 251605
5 10 453809
6 10 942947
7 10 378285
8 10 944748
9 10 761726
5 11 7926
6 11 237034
8 11 860297
9 11 224152
10 11 62671
7 12 518894
9 12 265459
10 12 399585
11 12 16993
7 13 935813
8 13 675125
9 13 986248
10 13 801332
11 13 775825
12 13 483974
8 14 879925
9 14 568657
10 14 539371
11 14 392819
12 14 673171
13 14 593981
9 15 893512
10 15 459005
11 15 935151
13 15 984026
14 15 352506
10 16 847405
11 16 902823
12 16 924659
14 16 31185
15 16 83802
11 17 225697
12 17 697702
13 17 431672
14 17 934227
15 17 64055
16 17 714592
12 18 429691
13 18 69217
16 18 916446
17 18 859123
13 19 675753
14 19 427831
15 19 3386
16 19 179655
17 19 148897
18 19 307554
14 20 291004
15 20 497622
16 20 669001
17 20 742221
18 20 662204
19 20 966218
20 93 6
00000101001110000010
1 2 710445
1 3 390108
2 3 871795
1 4 323940
2 4 1557
3 4 853515
1 5 987497
2 5 791951
3 5 565856
4 5 401932
1 6 49223
2 6 59889
3 6 300678
4 6 123895
5 6 160344
1 7 196308
3 7 787087
5 7 224478
6 7 104395
3 8 344509
4 8 173377
5 8 100930
7 8 544113
3 9 475119
4 9 673881
5 9 234187
6 9 191885
7 9 35559
8 9 872991
4 10 339910
5 10 624600
6 10 442925
7 10 821981
8 10 805172
9 10 463188
5 11 745511
6 11 444346
7 11 856170
8 11 10706
9 11 582739
10 11 666926
6 12 838187
7 12 711050
8 12 386931
9 12 886249
10 12 356669
11 12 14156
7 13 339092
8 13 578454
9 13 195419
10 13 600017
11 13 504670
12 13 753722
8 14 219160
9 14 281523
10 14 730539
11 14 890253
12 14 789909
13 14 995665
9 15 227552
10 15 125146
11 15 737706
12 15 697809
13 15 753633
14 15 248107
10 16 15962
11 16 178154
12 16 586355
13 16 32073
14 16 912542
15 16 913266
11 17 158548
12 17 35601
14 17 818081
15 17 39970
16 17 330500
12 18 207654
13 18 729538
14 18 642935
15 18 73734
16 18 676418
17 18 455930
13 19 945333
15 19 723755
16 19 67978
17 19 128589
18 19 647790
14 20 294150
15 20 681124
16 20 749167
17 20 480962
18 20 133266
19 20 928077
20 34 2
10000111010111001100
1 2 175025
1 3 372293
2 3 723523
2 4 828462
3 4 96614
3 5 496039
4 5 435856
4 6 728072
5 6 26736
5 7 658831
6 7 294479
6 8 971178
7 8 755365
7 9 467364
8 9 912893
8 10 88692
9 10 132051
9 11 939008
10 11 986048
11 12 676052
11 13 287187
12 13 304051
13 14 305223
14 15 610873
14 16 540274
15 16 494014
15 17 90777
16 17 157248
16 18 211384
17 18 718096
17 19 822166
18 19 366585
18 20 250962
19 20 231236
20 89 6
00110010100101111001
1 2 758268
1 3 205716
2 3 295263
1 4 207862
2 4 69876
3 4 179798
2 5 479889
3 5 953848
4 5 68337
1 6 833892
2 6 234107
4 6 772558
5 6 675566
2 7 942986
3 7 253909
4 7 95158
5 7 119424
6 7 316766
2 8 477692
3 8 406515
4 8 987774
5 8 808702
6 8 184409
7 8 500278
3 9 887393
4 9 469162
6 9 293078
7 9 205359
8 9 777079
5 10 313301
6 10 636761
7 10 846529
8 10 315392
9 10 477016
5 11 29206
6 11 840608
7 11 151527
8 11 877001
9 11 439665
10 11 907197
7 12 815137
8 12 530916
9 12 922868
11 12 827381
7 13 887939
8 13 638323
9 13 311582
10 13 169399
11 13 763999
12 13 695711
8 14 686748
9 14 400272
10 14 39935
11 14 528026
12 14 776064
13 14 965438
10 15 457267
12 15 318406
13 15 3489
14 15 217063
11 16 763755
12 16 711741
13 16 617167
14 16 469274
15 16 845875
11 17 776936
12 17 464487
13 17 682511
14 17 11831
15 17 447702
16 17 10247
12 18 10991
13 18 388512
14 18 312431
15 18 427326
16 18 846191
17 18 977005
13 19 941472
14 19 709497
15 19 343667
16 19 346238
17 19 777055
18 19 703066
14 20 779760
15 20 559561
16 20 810681
17 20 436275
18 20 371192
19 20 42384
```

**样例输出**

```
2402044
339126
523926
4622029
1721412
```

## 2、题解

## 3、参考程序

```

```



# CCF-CSP  201609-4 交通规划

## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 1.0s | 256.0MB |

**题目描述**

　　G国国王来中国参观后，被中国的高速铁路深深的震撼，决定为自己的国家也建设一个高速铁路系统。
　　建设高速铁路投入非常大，为了节约建设成本，G国国王决定不新建铁路，而是将已有的铁路改造成高速铁路。现在，请你为G国国王提供一个方案，将现有的一部分铁路改造成高速铁路，使得任何两个城市间都可以通过高速铁路到达，而且从所有城市乘坐高速铁路到首都的最短路程和原来一样长。请你告诉G国国王在这些条件下最少要改造多长的铁路。

**输入格式**

　　输入的第一行包含两个整数 $n, m$ ，分别表示G国城市的数量和城市间铁路的数量。所有的城市由1到 $n$ 编号，首都为1号。
　　接下来 $m$ 行，每行三个整数 $a, b, c$ ，表示城市 $a$ 和城市 $b$ 之间有一条长度为 $c$ 的双向铁路。这条铁路不会经过 $a$ 和 $b$ 以外的城市。

**输出格式**

　　输出一行，表示在满足条件的情况下最少要改造的铁路长度。

**样例输入**

```
4 5
1 2 4
1 3 5
2 3 2
2 4 3
3 4 2
```

**样例输出**

```
11
```

**评测用例规模与约定**

　　对于20%的评测用例，$1 ≤ n ≤ 10，1 ≤ m ≤ 50$；
　　对于50%的评测用例，$1 ≤ n ≤ 100，1 ≤ m ≤ 5000$；
　　对于80%的评测用例，$1 ≤ n ≤ 1000，1 ≤ m ≤ 50000$；
　　对于100%的评测用例，$1 ≤ n ≤ 10000，1 ≤ m ≤ 100000，1 ≤ a, b ≤ n，1 ≤ c ≤ 1000$。输入保证每个城市都可以通过铁路达到首都。

## 2、题解

**Prim**

　　Prim算法是寻找MST的另一种算法。不同于Kruskal算法将边权作为算法的主线，Prim算法从顶点出发构建MST，算法流程如下：

1.  考虑无向图 $G(V, E)$，建立点集 $U$，建立 $dis$ 数组，$dis[u]$ 用于表示 $u$ 到点集 $U$ 的最短距离。
2.  首先，将 $G$ 中任意一点作为起始点加入 $U$，此时该点的 $dis$ 值为0，其余各点 $dis$ 值为无穷。
3.  记最新加入 $U$ 的顶点为 $u$，遍历 $u$ 的所有邻接点，用边权去更新这些邻接点的 $dis$ 值。
4.  遍历 $V-U$ 集合（即还未进入 $U$ 的点），将 $dis$ 值最小的点即距离 $U$ 最近的点加入 $U$。
5.  重复以上操作直到 $U=V$，此时每一个点存储的 $dis$ 值就是它在MST中的一条边的边权，$∑dis$ 即MST的边权总和。

**本题分析**

　　回到题目本身，“任何两个城市间都可以通过高速铁路到达”和“最少要改造多长的铁路”两个条件实质上告诉我们需要寻找一颗MST，值得注意的是，题中有一个隐含条件“从所有城市乘坐高速铁路到首都的最短路程和原来一样长”，也就是说，我们MST中的边必须是各顶点到顶点1的最短路径上的边。

　　所以我们对算法做一点小小的改动，现在令 $dis$ 表示该点到顶点1的最短距离，再建立新的 $from$ 数组用于表示该点具体从哪一条边更新过来，更新操作中在两条路径最终 $dis$ 值相等时取 $from$ 值更小的一条，每次选择 $dis$ 值最小的点即距离顶点1最近的点加入 $U$，其余操作不变，$∑dis$ 即MST的边权总和。

　　另外，在Kruskal算法的基础上做相应的改动也能解决这道题，有兴趣的同学可以进行尝试。

## 3、参考程序

```C++
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<vector>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const int maxn=10000+10, INF=0x7f7f7f7f;

int n, m, dis[maxn], from[maxn];
bool vis[maxn];
struct node
{
	int v, c, id;
	node(int _v=0, int _c=0)
	{
		v=_v, c=_c;
	}
	bool operator <(const node&t)const
	{
		return c<t.c;
	}
};
vector<node> eg[maxn];

void Work()	//Prim求特殊MST
{
	memset(dis, 0x7f, sizeof dis);
	memset(vis, false, sizeof vis);
	memset(from, 0x7f, sizeof from);

	dis[1]=0;
	vis[1]=true;
	from[1]=0;

	int u=1, v, c, cur=INF, id, cnt=1;
	while(cnt++<n)
	{
		for(int i=0, len=eg[u].size(); i<len; i++)
		{
			v=eg[u][i].v, c=eg[u][i].c;
			if(dis[u]+c<dis[v] || (dis[u]+c==dis[v] && c<from[v]))	dis[v]=dis[u]+c, from[v]=c;
			//从两条路径都能得到相同的最小dis[v]时，选择使本次经过的边更短的那条路径
		}
		for(int i=1; i<=n; i++) if(!vis[i] && dis[i]<cur)	cur=dis[i], id=i;
		//选择距离顶点1更近的点加入新集合
		u=id, cur=INF, vis[u]=true;
	}
	
	int ans=0;
	for(int i=2; i<=n; i++)	ans+=from[i];	//计算所求MST的边权和
	printf("%d\n", ans);
	return ;
}

int main()
{
	while(scanf("%d%d", &n, &m)!=EOF)
	{
		for(int i=1; i<=n; i++)	eg[i].clear();
		for(int i=1, u, v, c; i<=m; i++)
		{
			scanf("%d%d%d", &u, &v, &c);
			eg[u].push_back(node(v, c));
			eg[v].push_back(node(u, c));
		}

		Work();
	}
	return 0;
}
```



# CCF-CSP  201609-5 祭坛

## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 2.0s | 256.0MB |

**题目描述**

　　在遥远的Dgeak大陆，生活着一种叫做Dar-dzo-nye的怪物。每当这种怪物降临，人们必须整夜对抗怪物而不能安睡。为了乞求这种怪物不再降临，人们决定建造祭坛。
　　Dgeak大陆可以看成一个用平面直角坐标系表示的巨大平面。在这个平面上，有 $n$ 个Swaryea水晶柱，每个水晶柱可以用一个点表示。
　　如果 4 个水晶柱依次相连可以构成一个四边形，满足其两条对角线分别平行于 $x$ 轴和 $y$ 轴，并且对角线的交点位于四边形内部（不包括边界），那么这 4 个水晶柱就可以建立一个结界。其中，对角线的交点称作这个结界的中心。
　　例如下左图中，水晶柱ABCD可以建立一个结界，其中心为O。
![](201609-5-1.png)![](201609-5-2.png)
　　为了起到抵御Dar-dzo-nye的最佳效果，人们会把祭坛修建在最多层结界的保护中。其中不同层的结界必须有共同的中心，这些结界的边界不能有任何公共点，并且中心处也不能有水晶柱。这里共同中心的结界数量叫做结界的层数。
　　为了达成这个目的，人们要先利用现有的水晶柱建立若干个结界，然后在某些结界的中心建立祭坛。
　　例如上右图中，黑色的点表示水晶柱（注意P和O点不是水晶柱）。祭坛的一个最佳位置为O点，可以建立在 3 层结界中，其结界的具体方案见下左图。当然，建立祭坛的最佳位置不一定是唯一，在上右图中，O 点左侧 1 单位的点 P 也可以建立一个在 3 层结界中的祭坛，见下右图。
![](201609-5-3.png)![](201609-5-4.png)
　　现在人们想知道：
​	1. 祭坛最佳选址地点所在的结界层数；
​	2. 祭坛最佳的选址地点共有多少个。

**输入格式**

　　输入的第一行包含两个正整数 $n,q$，表示水晶柱的个数和问题的种类。保证 $q=$ 1 或 2，其意义见输出格式。
　　接下来 $n$ 行，每行包含两个非负整数 $x,y$，表示每个水晶柱的坐标。保证相同的坐标不会重复出现。

**输出格式**

　　若 $q=1$，输出一行一个整数，表示祭坛最多可以位于多少个结界的中心；若 $q=2$，输出一行一个整数，表示结界数最多的方案有多少种。

**样例输入**

```
26 1
0 5
1 1
1 5
1 9
3 5
3 10
4 0
4 1
4 2
4 4
4 6
4 9
4 11
5 0
5 2
5 4
5 8
5 9
5 10
5 11
6 5
7 5
8 5
9 10
10 2
10 5
```

**样例输出**

```
3
```

**样例输入**

```
26 2
0 5
1 1
1 5
1 9
3 5
3 10
4 0
4 1
4 2
4 4
4 6
4 9
4 11
5 0
5 2
5 4
5 8
5 9
5 10
5 11
6 5
7 5
8 5
9 10
10 2
10 5
```

**样例输出**

```
2
```

**样例说明**

　　样例即为题目描述中的例子，两个样例数据相同，分别询问最多的结界数量和达到最多结界数量的方案数。
　　其中图片的左下角为原点，右和上分别是 $x$ 轴和 $y$ 轴的正方向，一个格子的长度为单位长度。
　　以图中的 O 点建立祭坛，祭坛最多可以位于 3 个结界的中心。不存在更多结界的方案，因此样例1的答案为 3。
　　在 O 点左侧 1 单位的点 (4,5) 也可以建立一个在 3 个结界中的祭坛，因此样例2的答案为 2。

**评测用例规模与约定**

　　对于所有的数据，保证存在至少一种方案，使得祭坛建造在至少一层结界中，即不存在无论如何祭坛都无法建造在结界中的情况。
　　数据分为 8 类，各类之间互相没有交集，分别有以下特点：
　　1. 占数据的 10%，$n=200，x,y≤n$；
　　2. 占数据的 10%，$n=200，x,y≤10^9$；
　　3. 占数据的 10%，$n=1000，x,y≤n$；
　　4. 占数据的 10%，$n=1000，x,y≤10^9$；
　　5. 占数据的 10%，$n=5000，x,y≤n$；
　　6. 占数据的 10%，$n=5000，x,y≤10^9$；
　　7. 占数据的 20%，$n=300000，x,y≤n$；
　　8. 占数据的 20%，$n=300000，x,y≤10^9$。
       此外，每类数据中，$q=1$ 与 $q=2$ 各占恰好一半。

## 2、题解

## 3、参考程序

```

```



# CCF-CSP  201612-4 压缩编码

## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 3.0s | 256.0MB |

**题目描述**

　　给定一段文字，已知单词 $a_1, a_2, …, a_n$ 出现的频率分别 $t_1, t_2, …, t_n$。可以用01串给这些单词编码，即将每个单词与一个01串对应，使得任何一个单词的编码（对应的01串）不是另一个单词编码的前缀，这种编码称为前缀码。
　　使用前缀码编码一段文字是指将这段文字中的每个单词依次对应到其编码。一段文字经过前缀编码后的长度为：
　　$L=a_1$ 的编码长度 $×t_1+a_2$ 的编码长度 $×t_2+…+ a_n$ 的编码长度 $×t_n$。
　　定义一个前缀编码为字典序编码，指对于 $1 ≤ i < n$ ， $a_i$ 的编码（对应的01串）的字典序在 $a_{i+1}$ 编码之前，即 $a_1, a_2, …, a_n$ 的编码是按字典序升序排列的。
　　例如，文字 $E\ A\ E\ C\ D\ E\ B\ C\ C\ E\ C\ B\ D\ B\ E$ 中， 5个单词 $A$、$B$、$C$、$D$、$E$ 出现的频率分别为1, 3, 4, 2, 5，则一种可行的编码方案是 $A:000,\ B:001,\ C:01,\ D:10,\ E:11$ ，对应的编码后的01串为1100011011011001010111010011000111，对应的长度 $L$ 为3×1+3×3+2×4+2×2+2×5=34。
　　在这个例子中，如果使用哈夫曼(Huffman)编码，对应的编码方案是 $A:000,\ B:01,\ C:10,\ D:001,\ E:11$，虽然最终文字编码后的总长度只有33，但是这个编码不满足字典序编码的性质，比如 $C$ 的编码的字典序不在 $D$ 的编码之前。
　　在这个例子中，有些人可能会想的另一个字典序编码是 $A:000,\ B:001,\ C:010,\ D:011,\ E:1$ ，编码后的文字长度为35。
　　请找出一个字典序编码，使得文字经过编码后的长度 $L$ 最小。在输出时，你只需要输出最小的长度 $L$，而不需要输出具体的方案。在上面的例子中，最小的长度 $L$ 为34。

**输入格式**

　　输入的第一行包含一个整数 $n$，表示单词的数量。
　　第二行包含 $n$ 个整数，用空格分隔，分别表示 $a_1, a_2, …, a_n$ 出现的频率，即 $t_1, t_2, …, t_n$。请注意 $a_1, a_2, …, a_n$ 具体是什么单词并不影响本题的解，所以没有输入 $a_1, a_2, …, a_n$。

**输出格式**

　　输出一个整数，表示文字经过编码后的长度 $L$ 的最小值。

**样例输入**

```
5
1 3 4 2 5
```

**样例输出**

```
34
```

**评测用例规模与约定**

　　对于30%的评测用例，$1 ≤ n ≤ 10，1 ≤ t_i ≤ 20$；
　　对于60%的评测用例，$1 ≤ n ≤ 100，1 ≤ t_i ≤ 100$；
　　对于100%的评测用例，$1 ≤ n ≤ 1000，1 ≤ t_i ≤ 10000$。

## 2、题解

**石子合并**

　　在这个模型中，我们要将 $n$ 堆石子有序地合并成一堆，规定每次只能移动相邻的2堆石子合并，每次合并的代价为新合成的一堆石子的数量，求完成任务的最小代价。这个问题可以用DP解决，设 $f[i][j]$ 表示合并第 $i$ 堆到第 $j$ 堆石子的最小代价，显然我们最终的需要的答案就是 $f[1][n]$，不难得到状态转移方程：
$$
f[i][j]=\begin{cases}
0& \text i=j\\
min(f[i][k]+f[k+1][j])_{i<=k<j}+sum[i][j] &\text i\neq j\\
\end{cases}
$$
​	其中 $sum[i][j]$ 表示第 $i$ 堆到第 $j$ 堆石子的总数量。

**本题分析**

​	由题目描述我们知道任意编码都不能是其他编码的前缀，因此在我们构建的编码树中，每个字母一定对应着一个叶子结点，这里我们采用自底向上的思想，考虑将 $n$ 个节点合并到一颗编码树的最小代价，而题目又要遵循字典序，也就是说我们只能考虑相邻节点进行合并，而不能采用哈夫曼编码的思想每次合并代价最小的两个节点。

​	这里我们采用石子合并模型，朴素算法复杂度为 $O(n^3)$，对于CCF的题目规模已经足够了。在题目规模更大的时候，使用平行四边形优化能够将算法复杂度降为O(n^2)，有兴趣的同学可以自行了解学习。　

## 3、参考程序

```C++
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const int maxn=1000+10, INF=0x7f7f7f7f;

int n, a[maxn], s[maxn], f[maxn][maxn];

int main()
{
	while(scanf("%d", &n)!=EOF)
	{
		memset(s, 0, sizeof s);
		memset(f, 0x7f, sizeof f);
		for(int i=1; i<=n; i++)	scanf("%d", &a[i]);
		for(int i=1; i<=n; i++)	s[i]=s[i-1]+a[i], f[i][i]=0;
		//s[i]为前i个点的频率和，f[i][i]表示第i堆到第i堆的代价

		for(int i=n; i; i--)
		//计算f[i][j]时会使用f[k+1][j]的值，这要求f[k+1][j]已被计算过，所以这里循环顺序必须从大到小，注意理解
			for(int j=i+1; j<=n; j++)
			{
				int tmp=INF;
				for(int k=i; k<j; k++) tmp=min(tmp, f[i][k]+f[k+1][j]);
				f[i][j]=tmp+s[j]-s[i-1];
			}
		printf("%d\n", f[1][n]);
	}
	return 0;
}
```



# CCF-CSP  201612-5 卡牌游戏

## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 3.0s | 256.0MB |

**题目描述**

　　小Q和小M是游戏数值策划师，他们最近在测试自己新设计的卡牌对战游戏。游戏总共有 $n$ 张卡牌，用 1 到 $n$ 的正整数编号。最开始小Q和小M各会拥有其中的一部分。
　　每一局游戏，小Q和小M都需要从自己拥有的卡牌中选出一张进行对战，获胜的一方会获得双方选出的两张卡牌。游戏会一直进行下去，直到其中一个人获得了所有的卡牌，此时获得所有卡牌的一方赢得了最终的胜利。
　　对于一对特定的卡牌 $i$ 和 $j$，$i$ 战胜 $j$ 的概率为 $P_{i, j}$。此概率与其他事件独立，只与选出的这两张卡牌有关系；每次对战一定会决出胜负，因此有 $P_{i,j} + P_{j,i} = 1$。
　　小Q和小M都没有好好学习博弈论，已经忘了混合决策那套理论。经过商量，他们采取了同一套看起来合理的选牌方式：

​	1. 对于自己的卡牌 $i$，计算出这张卡牌能赢得对方每张卡牌的概率之和 $S_i=∑_j$ 是对方的卡牌 $P_{i, j}$；

​	2. 令自己选出卡牌i的概率正比于 $S_i$，即选出 $i$ 的概率为 $S_i/∑_k$ 是自己的卡牌 $S_k$。
　　小M想知道，对于给出的 $m$ 种初始状态，他最终获胜的概率是多少。

**输入格式**

　　从标准输入读入数据。
　　输入的第一行包含两个正整数 $n, m$ 表示卡牌的数量和初始状态的数量。
　　接下来 $n-1$ 行。其中的第 $i$ 行（$1 ≤ i < n$）包含 $n - i$ 个恰好含有 2 位小数的浮点数；该行的第 $j$ 个（$1 ≤ j ≤ n - i$）数表示 $P_{i, i+j}$。
　　保证上述每个 $P_{i,j}$ 均是直接调用伪随机数生成函数生成一个 [10, 90] 上的整数，然后除以 100 得到；即可以认为每个数都是从 [0.10, 0.90] 上的所有 2 位小数中，独立等概率取得的。
　　接下来 $m$ 行，每行包含 $n$ 个 0 或 1 的整数，描述一个初始状态。这 $n$ 个数中的第 $i$ 个如果是 1 表示第 $i$ 张牌最初在小M手中，否则表示这张牌在小Q手中。
　　保证询问两两不同。

**输出格式**

　　输出到标准输出。
　　输出 $m$ 行，每行输出一个小数部分长度恰好为5的浮点数，表示小M的每种初始状况最终获胜的概率四舍五入后的结果。
　　你答案中的每个数必须和参考答案完全一样才能获得相应测试点的分数。
　　保证参考答案与真实答案的差值不超过 $4 × 10^{-6}$。

**样例输入**

```
3 4
0.46 0.21
0.86
0 0 0
1 1 0
0 0 1
1 1 1
```

**样例输出**

```
0.00000
0.83488
0.16512
1.00000
```

**样例说明**

| 局面编号  | 小M的牌 | 小Q的牌 | $S_1$ | $S_2$ | $S_3$ | 小M的 $S_i$ 之和 | 小Q的 $S_i$ 之和 |
| ----- | ---- | ---- | ----- | ----- | ----- | ------------ | ------------ |
| $x_1$ | 1    | 2,3  | 0.67  | 0.54  | 0.79  | 0.67         | 1.33         |
| $x_2$ | 2    | 1,3  | 0.46  | 1.40  | 0.14  | 1.40         | 0.60         |
| $x_3$ | 3    | 1,2  | 0.21  | 0.86  | 0.93  | 0.93         | 1.07         |

　　我们设 $P (x)$ 为当前局面为 $x$，最终小M获胜的概率，例如 $P (x_1)$ 表示小M手里的牌为 1 最终获胜的概率。
　　定义事件 $\wedge x$ 为将局面 $x$ 中双方手里的牌互换的局面，根据对称性易得 $P( \wedge x)=1 - P (x)$。
　　对于全部牌都在小M手里的情况，小M已经赢得了胜利，此种情况下小M获胜概率为 1；相反，牌全部在小Q手里的话，小M获胜概率为 0。
　　对于局面 $x_1$：小M由于只有一张牌 1，因此他必须出这张牌；小Q根据之前的选牌策略，他有 0.54/1.33 的概率出 2，有 0.79/1.33 的概率出 3。若小Q出 2：则小M有 0.46 的概率会赢得这张牌，从而进入局面 $\wedge x_3$；有 1-0.46 的概率会输掉手中最后一张 1。若小Q出 3：则小M有 0.21 的概率会赢得这张牌，从而进入局面 $\wedge x_2$；有 1-0.21 的概率会输掉最后一张 1。因此，可以得出
　　![](201612-5-1.png)
　　同理，可以求出 $P (x_2)$ 和 $P (x_3)$ 的表达式：
　　![](201612-5-2.png)
　　注意到 0.2484/1.33， 0.1204/0.60 等数均小于 1，我们可以将三个式子互相不断代入各自的等式右边，得到一个收敛的级数。对这个级数求和就能求出样例的答案。

**样例输入**

```
2 4
0.34
0 0
1 0
0 1
1 1
```

**样例输出**

```
0.00000
0.34000
0.66000
1.00000
```

**样例输入**

```
4 8
0.81 0.34 0.73
0.85 0.50
0.22
0 0 0 0
1 0 1 0
0 1 1 0
1 1 1 0
0 0 0 1
1 0 0 1
0 1 0 1
1 1 1 1
```

**样例输出**

```
0.00000
0.61095
0.38546
0.80232
0.19768
0.61454
0.38905
1.00000
```

**样例输入**

```
5 20
0.45 0.28 0.48 0.59
0.61 0.88 0.66
0.19 0.67
0.11
0 0 0 0 0
1 0 0 0 0
0 1 0 0 0
0 0 1 0 0
1 0 1 0 0
1 0 0 1 0
1 1 0 1 0
0 0 1 1 0
1 0 1 1 0
1 1 1 1 0
0 0 0 0 1
0 1 0 0 1
1 1 0 0 1
0 0 1 0 1
0 1 1 0 1
0 1 0 1 1
1 1 0 1 1
1 0 1 1 1
0 1 1 1 1
1 1 1 1 1
```

**样例输出**

```
0.00000
0.15693
0.30992
0.16074
0.35568
0.28030
0.63788
0.31579
0.52478
0.85575
0.14425
0.47522
0.68421
0.36212
0.71970
0.64432
0.83926
0.69008
0.84307
1.00000
```

**评测用例规模与约定**

　　总共 20 组评测数据。对于第 $i$ 组数据（$1 ≤ i ≤ 20$）：若 $i ≤ 10，n=⌈i / 2⌉$；若 $i > 10，n = i-5$。

## 2、题解

## 3、参考程序

```

```



# CCF-CSP  201703-4 地铁修建

## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 1.0s | 256.0MB |

**题目描述**

​	A市有 $n$ 个交通枢纽，其中1号和 $n$ 号非常重要，为了加强运输能力，A市决定在1号到 $n$ 号枢纽间修建一条地铁。
　　地铁由很多段隧道组成，每段隧道连接两个交通枢纽。经过勘探，有 $m$ 段隧道作为候选，两个交通枢纽之间最多只有一条候选的隧道，没有隧道两端连接着同一个交通枢纽。
　　现在有 $n$ 家隧道施工的公司，每段候选的隧道只能由一个公司施工，每家公司施工需要的天数一致。而每家公司最多只能修建一条候选隧道。所有公司同时开始施工。
　　作为项目负责人，你获得了候选隧道的信息，现在你可以按自己的想法选择一部分隧道进行施工，请问修建整条地铁最少需要多少天。

**输入格式**

　　输入的第一行包含两个整数 $n, m$，用一个空格分隔，分别表示交通枢纽的数量和候选隧道的数量。
　　第2行到第 $m+1$ 行，每行包含三个整数 $a, b, c$，表示枢纽 $a$ 和枢纽 $b$ 之间可以修建一条隧道，需要的时间为 $c$ 天。

**输出格式**

　　输出一个整数，修建整条地铁线路最少需要的天数。

**样例输入**

```
6 6
1 2 4
2 3 4
3 6 7
1 4 2
4 5 5
5 6 6
```

**样例输出**

```
6
```

**样例说明**

　　可以修建的线路有两种。
　　第一种经过的枢纽依次为1, 2, 3, 6，所需要的时间分别是4, 4, 7，则整条地铁线需要7天修完；
　　第二种经过的枢纽依次为1, 4, 5, 6，所需要的时间分别是2, 5, 6，则整条地铁线需要6天修完。
　　第二种方案所用的天数更少。

**评测用例规模与约定**

　　对于20%的评测用例，$1 ≤ n ≤ 10，1 ≤ m ≤ 20$；
　　对于40%的评测用例，$1 ≤ n ≤ 100，1 ≤ m ≤ 1000$；
　　对于60%的评测用例，$1 ≤ n ≤ 1000，1 ≤ m ≤ 10000，1 ≤ c ≤ 1000$；
　　对于80%的评测用例，$1 ≤ n ≤ 10000，1 ≤ m ≤ 100000$；
　　对于100%的评测用例，$1 ≤ n ≤ 100000，1 ≤ m ≤ 200000，1 ≤ a, b ≤ n，1 ≤ c ≤ 1000000$。
　　所有评测用例保证在所有候选隧道都修通时1号枢纽可以通过隧道到达其他所有枢纽。

## 2、题解

**本题分析**

　　这道题目的描述比较复杂，现在我们从现实背景中抽离出来，这道题目实际上对应了这样一个问题：给定含 $n$ 个点、$m$ 条边的简单无向图，要求选择这样一条路径，满足起点为1终点为 $n$，且路径上的总边数不大于 $n$，问路径上最长边最短为多少。

　　建模之后题目就变得清晰了，我们需要寻找的是一条从顶点1出发的最短路，只是区别于传统的最短路，这里对距离的定义是路径上最长边的长度，同样可以用SPFA算法解决，只需要对松弛操作进行相应的改动。

## 3、参考程序

```c++
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<queue>
#include<cmath>
#include<algorithm>
using namespace std;
const int maxn=100000+10, maxm=200000+10, INF=0x7f7f7f7f;

int n, m, dis[maxn], from[maxn];
int cur, fir[maxn], ver[maxm<<1], nxt[maxm<<1], prc[maxm<<1];
bool vis[maxn];

void Add(int u, int v, int c)
{
	ver[++cur]=v, nxt[cur]=fir[u], fir[u]=cur, prc[cur]=c;
	ver[++cur]=u, nxt[cur]=fir[v], fir[v]=cur, prc[cur]=c;
	return ;
}

int Work()
{
	memset(from, 0, sizeof from);
	memset(dis, 0x7f, sizeof dis);
	memset(vis, false, sizeof vis);
	
	queue<int> q;
	q.push(1);
	dis[1]=0, vis[1]=true;
	
	while(!q.empty())
	{
		int u=q.front();

		for(int i=fir[u], v; i; i=nxt[i])	if(max(dis[u], prc[i])<dis[v=ver[i]])
		{
			dis[v]=max(dis[u], prc[i]);
			from[v]=u;
			if(!vis[v])
			{
				q.push(v);
				vis[v]=true;
			}
		}
		
		q.pop();
		vis[u]=false;
	}
	
	return dis[n];
}

int main()
{
	while(scanf("%d%d", &n, &m)!=EOF)
	{
		cur=0;
		memset(fir, 0, sizeof fir);
		
		for(int i=1, u, v, c; i<=m; i++)
		{
			scanf("%d%d%d", &u, &v, &c);
			Add(u, v, c);
		}
		
		printf("%d\n", Work());
	}
	return 0;
}
```



# CCF-CSP  201703-5 引水入城

## 1、题目

| 时间限制 | 内存限制    |
| ---- | ------- |
| 2.0s | 512.0MB |

**题目描述**

​	MF城建立在一片高原上。由于城市唯一的水源是位于河谷地带的湖中，人们在坡地上修筑了一片网格状的抽水水管，以将湖水抽入城市。如下图所示：
![](201703-5.png)
　　这片管网由 $n$ 行 $m$ 列节点（红色，图中 $n = 5，m = 6$），横向管道（紫色）和纵向管道（橙色）构成。
　　行和列分别用 1 到 $n$ 的整数和 1 到 $m$ 的整数表示。第 1 行的任何一个节点均可以抽取湖水，湖水到达第 $n$ 行的任何一个节点即算作引入了城市。
　　除第一行和最后一行外，横向相邻或纵向相邻的两个节点之间一定有一段管道，每一段管道都有各自的最大的抽水速率，并需要根据情况选择抽水还是放水。对于纵向的管道（橙色），允许从上方向下方抽水或从下方向上方放水；如果从图中的上方向下方抽水，那么单位时间内能通过的水量不能超过管道的最大速率；如果从下方向上方放水，因为下方海拔较高，因此可以允许有任意大的水量。对于横向的管道（紫色），允许从左向右或从右向左抽水，不允许放水，两种情况下单位时间流过的水量都不能超过管道的最大速率。
　　现在MF城市的水务负责人想知道，在已知每个管道单位时间容量的情况下，MF城每单位时间最多可以引入多少的湖水。

**输入格式**

　　由于输入规模较大，我们采用伪随机生成的方式生成数据。
　　每组数据仅一行包含 6 个非负整数 $n, m, A, B, Q, X_0$。其中，$n$ 和 $m$ 如前文所述，表示管网的大小，保证 $2 ≤ n, m ≤ 5000$；保证 $1 ≤ A, B, Q, X_0 ≤ 10^9$。
　　$A, B, Q, X_0$ 是数据生成的参数，我们用如下的方式定义一个数列 $\{ X_i \}$：
　　$X_{i+1} = ( AX_i + B) mod Q, (i ≥ 0)$
　　我们将数列的第 1 项到第 $(n-1)m$ 项作为纵向管道的单位时间容量，其中 $X_{(s-1)m+t}$ 表示第 $s$ 行第 $t$ 列的节点到第 $s+1$ 行第 $t$ 列管道单位时间的容量；将数列的第 $(n-1)m+1$ 项到第 $(n-1)m+(n-2)(m-1)$ 项（即接下来的 $(n-2)(m-1)$ 项）作为横向管道的单位时间容量，其中 $X_{(n-1)m+(s-2)(m-1)+t}$ 表示第 $s$ 行第 $t$ 列的节点到第 $s$ 行第 $t+1$ 列管道单位时间的容量。

**输出格式**

​	输出一行一个整数，表示MF城每单位时间可以引入的水量。
　　注意计算过程中有些参数可能超过32位整型表示的最大值，请注意使用64位整型存储相应数据。

**样例输入**

```
3 3 10 3 19 7
```

**样例输出**

```
38
```

**样例解释**

　　使用参数得到数列 ${ X_i }={ 7, 16, 11, 18, 12, 9, 17, 2, 4, … }$，按照输入格式可以得到每个管道的最大抽水量如下图所示：
![](201703-5-2.png)

　　在标准答案中，单位时间可以引水 38 单位。所有纵向管道均向下抽水即可，不需要横向管道抽水，也不需要向上放水。

**样例输入**

```
2 5 595829232 749238243 603779819 532737791
```

**样例输出**

```
1029036148
```

**样例输入**

```
5 2 634932890 335818535 550589587 977780683
```

**样例输出**

```
192923706
```

**样例输入**

```
5 5 695192542 779962396 647834146 157661239
```

**样例输出**

```
1449991168
```

**评测用例规模与约定**

　　共有10组评测数据，每组数据的参数规模如下所示：

| 测试点  | 1     | 2     | 3     | 4    | 5    | 6    | 7    | 8     | 9     | 10    |
| ---- | ----- | ----- | ----- | ---- | ---- | ---- | ---- | ----- | ----- | ----- |
| $n$  | =2    | =1000 | =1000 | =5   | =10  | =100 | =500 | =1000 | =2000 | =5000 |
| $m$  | =1000 | =2    | =2    | =5   | =10  | =100 | =500 | =1000 | =2000 | =5000 |

## 2、题解

## 3、参考程序

```c++

```
